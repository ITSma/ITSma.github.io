<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ITS&#39;Ma Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://itsma.github.io/"/>
  <updated>2018-08-17T01:50:30.496Z</updated>
  <id>https://itsma.github.io/</id>
  
  <author>
    <name>ITS-Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/undefined.html"/>
    <id>https://itsma.github.io/[object Object]/undefined.html</id>
    <published>2018-08-17T01:50:30.496Z</published>
    <updated>2018-08-17T01:50:30.496Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/mergesort.html"/>
    <id>https://itsma.github.io/[object Object]/mergesort.html</id>
    <published>2018-08-16T09:56:24.000Z</published>
    <updated>2018-08-17T01:49:56.752Z</updated>
    
    <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""><p>归并排序的基本思想也是分治法。与快速排序不一样的是，归并排序是先分后治，而快排是先治后分</p><a id="more"></a><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="../../../../图片/ms.png" alt=""></the></p><p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现。</p><h3 id="分"><a href="#分" class="headerlink" title="分"></a>分</h3><p>在<strong>分</strong>的阶段可以采用递归方法实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=end)<span class="keyword">return</span>;<span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="comment">//分</span></span><br><span class="line">    <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;<span class="comment">//将数组从中间分开</span></span><br><span class="line">    mergeSort(arr,start,mid);</span><br><span class="line">    mergeSort(arr,mid+<span class="number">1</span>,end);</span><br><span class="line">    <span class="comment">//治</span></span><br><span class="line">    merge(arr,start,mid,end,temp);<span class="comment">//合并两个有序数组arr[start,mid]和arr[mid+1,end]到数组temp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="治"><a href="#治" class="headerlink" title="治"></a>治</h3><p>在<strong>治</strong>的阶段将问题转化为了<strong>合并相邻有序子序列</strong>：</p><p>例如，｛８｝和｛４｝｛４，８｝和｛５，７｝｛４，５，７，８｝和｛１，２，３，６｝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> mid,<span class="keyword">int</span> end,<span class="keyword">int</span> *temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=start;　<span class="comment">//左序列指针</span></span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>; <span class="comment">//右序列指针</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="comment">//临时数组指针</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=end)&#123;</span><br><span class="line">        temp[k++]=((arr[i]&lt;arr[j])?arr[i++]:arr[j++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        temp[k++]=arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=end)&#123;</span><br><span class="line">        temp[k++]=arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;=end)&#123;　<span class="comment">//小于等于</span></span><br><span class="line">        arr[start++]=arr[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>合并操作merge()的平均复杂度是<strong>$O(N)$</strong></p><p>拆分操作是完全二叉树的深度，时间复杂度是<strong>$O(NlogN)$</strong></p><p>所以，最坏、最好和平均时间复杂度都是<strong>$O(NlogN)$</strong>。</p><h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a><strong>稳定</strong>排序</h3><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>缺点：需要额外的空间。开辟与arr数组一样大小的空间来存储排好的序列。</p><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">参考</a></p></excerpt>]]></content>
    
    <summary type="html">
    
      &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;

&lt;p&gt;归并排序的基本思想也是分治法。与快速排序不一样的是，归并排序是先分后治，而快排是先治后分&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://itsma.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://itsma.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/quicksort.html"/>
    <id>https://itsma.github.io/[object Object]/quicksort.html</id>
    <published>2018-08-14T11:43:42.000Z</published>
    <updated>2018-08-17T01:47:58.931Z</updated>
    
    <content type="html"><![CDATA[<p> <excerpt in="" index="" |="" 首页摘要=""><br>快速排序是由冒泡排序演变而来，都属于交换排序。快速排序之所以快速，是因为采用了分治法。<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>快速排序属于交换排序，通过元素之间的比较和交换位置来达到排序目的。不同的是，冒泡排序每一轮只把一个元素冒泡到数组一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数组一边，比它小的移动到数组另一边，从而把数组拆解成两个部分。这种思想就是分治法。</the></p><p>在分治法的思想下，原数列在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。</p><p>这样一共需要多少轮呢？平均情况下需要$logN$轮，因此快速排序算法的平均时间复杂度是 <strong>O(NlogN)</strong></p><h3 id="分"><a href="#分" class="headerlink" title="分"></a>分</h3><p>在分的阶段，就是将基准元素左边序列和右边序列再次治理。可以用递归实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//start指向第一个元素，end指向数组最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(start&lt;=end)<span class="keyword">return</span>; <span class="comment">//递归结束条件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//治</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex=partition(arr,start,end); <span class="comment">//进行一次快排，返回分治后基准元素在数组中的位置下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分</span></span><br><span class="line">    qucikSort(arr,start,pivotIndex<span class="number">-1</span>); <span class="comment">//左边递归</span></span><br><span class="line">    quickSort(arr,pivotIndex+<span class="number">1</span>,end);　<span class="comment">//右边递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###　治</p><p>在治的阶段，就是进行一次排序，把数组中大于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。即partition()函数</p><p>partition函数的实现方法有两种：</p><ul><li>挖坑法</li><li>指针交换法</li></ul><h4 id="递归挖坑法"><a href="#递归挖坑法" class="headerlink" title="递归挖坑法"></a>递归挖坑法</h4><p>两个指针start和end分别指向数组的最左和最右两个元素。</p><ol><li>选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴，也是初始的坑位。</li><li>设置两个变量left = 0;right = N - 1;</li><li>从left一直向后走，直到找到一个大于key的值，然后将该数放入坑中，坑位变成了array[left]。</li><li>right一直向前走，直到找到一个小于key的值，然后将该数放入坑中，坑位变成了array[right]。</li><li>重复3和4的步骤，直到left和right相遇，然后将key放入最后一个坑位。</li></ol><p><strong>注意，以第一个元素(start)作为基准元素时，则end先动。否则，以最后的元素(end)作为基准元素，应该(start)先动。start走的时候end是不动的，反之亦然。因为end先走，所有最后一个坑肯定在arr[start]。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挖坑法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot=arr[start]; <span class="comment">//基准元素</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(strat&lt;end &amp;&amp; arr[end]&gt;=pivot )&#123;　<span class="comment">//大于等于</span></span><br><span class="line">            end--;   <span class="comment">//保持不动</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[start]=arr[end];　<span class="comment">//填“坑”</span></span><br><span class="line">        <span class="comment">//start++;</span></span><br><span class="line">        <span class="keyword">while</span>(start&lt;end &amp;&amp; arr[start]&lt;=pivot )&#123; <span class="comment">//小于等于</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[end]=arr[start];　<span class="comment">//填“坑”</span></span><br><span class="line">        <span class="comment">//end--;</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[start]=pivot;　<span class="comment">//将基准元素填入最后的“坑”中　此时start&gt;=end</span></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归指针交换法"><a href="#递归指针交换法" class="headerlink" title="递归指针交换法"></a>递归指针交换法</h4><p>两个指针left和right分别指向数组的最左start和最右end两个元素。</p><ol><li>选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴。</li><li>设置两个变量left = 0;right = N - 1;</li><li>从left一直向后走，直到找到一个大于key的值，right从后至前，直至找到一个小于key的值，然后交换这两个数。</li><li>重复第三步，一直往后找，直到left和right相遇，这时将key放置left的位置即可</li></ol><p><img src="../../../../图片/qs.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot=arr[start];</span><br><span class="line">    <span class="keyword">int</span> left=start; <span class="comment">//左指针</span></span><br><span class="line">    <span class="keyword">int</span> right=end; <span class="comment">//右指针</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;pivot )&#123;　<span class="comment">//没有等于号</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;pivot )&#123; <span class="comment">//没有等于号</span></span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[left];</span><br><span class="line">        arr[left]=arr[right];</span><br><span class="line">        a[right]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=arr[left]; <span class="comment">//指针重合,交换基准元素与指针位置元素</span></span><br><span class="line">    arr[left]=arr[start];</span><br><span class="line">    arr[start]=t</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>递归的算法主要是在划分子区间，如果要非递归实现快排，只要使用一个栈来保存区间就可以了。  一般将递归程序改成非递归首先想到的就是使用栈，因为递归本身就是一个压栈的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    stk.push(start);　<span class="comment">//左指针先入栈</span></span><br><span class="line">    stk.push(end);</span><br><span class="line">    <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> right=stk.top(); <span class="comment">//右指针先出栈</span></span><br><span class="line">        stk.pop();</span><br><span class="line">        <span class="keyword">int</span> left=stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivotIndex=partition(arr,left,right);</span><br><span class="line">        <span class="keyword">if</span>(pivotIndex<span class="number">-1</span>&gt;left)&#123;　<span class="comment">//注意是left还是start，</span></span><br><span class="line">            stk.push(start);  <span class="comment">//注意入栈顺序，先入左边再入右边,push数组最左端的位置即start</span></span><br><span class="line">            stk.push(pivotIndex<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pivotIndex+<span class="number">1</span>&lt;right)&#123;<span class="comment">//判断的是基准位置与排序区间，应该是partition的left和right</span></span><br><span class="line">            stk.push(pivotIndex+<span class="number">1</span>);</span><br><span class="line">            stk.push(end);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>不稳定排序</strong></p><p>比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p><p>时间复杂度</p><p>最坏：在基准元素是数组最大或者最小值时，时间复杂度是<strong>$O(N^2)$</strong></p><p>最好：基准元素是中间值。时间复杂度是$O(NlogN)$</p><p>平均：<strong>$O(NlogN)$</strong></p><p><a href="https://blog.csdn.net/qq_36528114/article/details/78667034" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;快速排序是由冒泡排序演变而来，都属于交换排序。快速排序之所以快速，是因为采用了分治法。&lt;br&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://itsma.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://itsma.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Google浏览器插件</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/webtools.html"/>
    <id>https://itsma.github.io/[object Object]/webtools.html</id>
    <published>2018-08-02T02:46:13.000Z</published>
    <updated>2018-08-02T02:54:54.357Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Google浏览器插件：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>适合自己的才是最好的。个人常用插件集合<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p>书签管理</p><h2 id="新标签页"><a href="#新标签页" class="headerlink" title="新标签页"></a>新标签页</h2><p>Infinity新标签页</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Surfingkeys</p><h2 id="网络代理"><a href="#网络代理" class="headerlink" title="网络代理"></a>网络代理</h2><p>Proxy SwitchyOmega</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>YAAW for Chrome</p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>有道词典Chrome划词插件</p><h2 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h2><p>购物党全网比价工具</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Google浏览器插件：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;适合自己的才是最好的。个人常用插件集合&lt;br&gt;
    
    </summary>
    
      <category term="开发工具" scheme="https://itsma.github.io/categories/DevTools/"/>
    
    
      <category term="Devtools" scheme="https://itsma.github.io/tags/Devtools/"/>
    
  </entry>
  
  <entry>
    <title>Google编程规范</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/googleGuide.html"/>
    <id>https://itsma.github.io/[object Object]/googleGuide.html</id>
    <published>2018-08-01T09:12:11.000Z</published>
    <updated>2018-08-01T09:15:00.119Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Google编程规范：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>Google的C++开源项目编程规范<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="C-编程规范"><a href="#C-编程规范" class="headerlink" title="C++编程规范"></a>C++编程规范</h2><h3 id="1，头文件"><a href="#1，头文件" class="headerlink" title="1，头文件"></a>1，头文件</h3><h4 id="1-1-头文件可以自给自足，可以作为第一个引入的头文件"><a href="#1-1-头文件可以自给自足，可以作为第一个引入的头文件" class="headerlink" title="1.1 头文件可以自给自足，可以作为第一个引入的头文件"></a>1.1 头文件可以自给自足，可以作为第一个引入的头文件</h4><h4 id="1-2-define保护"><a href="#1-2-define保护" class="headerlink" title="1.2 define保护"></a>1.2 define保护</h4><p>项目 <code>foo</code> 中的头文件 <code>foo/src/bar/hd.h</code> 可按如下方式保护:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOO_BAR_HD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_BAR_HD_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//FOO_BAR_HD_H_</span></span></span><br></pre></td></tr></table></figure><h4 id="1-3-尽量避免使用前置声明。使用-include-包含需要的头文件即可。"><a href="#1-3-尽量避免使用前置声明。使用-include-包含需要的头文件即可。" class="headerlink" title="1.3 尽量避免使用前置声明。使用 #include 包含需要的头文件即可。"></a>1.3 尽量避免使用前置声明。使用 <code>#include</code> 包含需要的头文件即可。</h4><p>前置声明就是我在声明一个类（CHouse）的时候，用到了另外一个类的定义（CBed），但是CBed还没有定义呢，而且我还先不需要CBed的定义，只要知道CBed是一个类就够了。那好，我就先声明类CBed，告诉编译器CBed是一个类（不用包含CBed的头文件，然后在CHouse中用到CBed的，都用CBed的指针类型代（因为指针类型固定大小的，但是CBed的大小只用知道了CBed定义才能确定）。等到要实现CHouse定义的时候，就必须要知道CBed的定义了，那是再包好CBed的头文件就行了。</p><ul><li>尽量避免前置声明那些定义在其他项目中的实体.</li><li>函数：总是使用 <code>#include</code>.</li><li>类模板：优先使用 <code>#include</code>.</li></ul><h4 id="1-4-只有当函数少于10行时才将其定义为内联函数"><a href="#1-4-只有当函数少于10行时才将其定义为内联函数" class="headerlink" title="1.4 只有当函数少于10行时才将其定义为内联函数."></a>1.4 只有当函数少于10行时才将其定义为内联函数.</h4><p>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</p><p>不内联的情况：</p><ul><li>循环或switch语句</li><li>析构函数，虚函数，递归函数</li></ul><p>内联函数必须放在 <code>.h</code> 文件中. 如果内联函数比较短, 就直接放在 <code>.h</code> 中.</p><h4 id="1-5-include的路径和顺序"><a href="#1-5-include的路径和顺序" class="headerlink" title="1.5 #include的路径和顺序"></a>1.5 #include的路径和顺序</h4><p><code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能, <code>foo.cc</code> 中包含头文件的次序如下:</p><ol><li>cpp直接的头文件(dir2/foo2.h)</li><li>C库</li><li>C++库</li><li>其他库的头文件</li><li>项目内的头文件</li></ol><p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code> 遗漏某些必要的库时， <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p><p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意</p><p>您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，哪怕您所包含的 <code>foo.h</code> 已经包含了 <code>bar.h</code>, 也照样得包含 <code>bar.h</code>, 除非 <code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的 symbol. </p><h3 id="2，作用域"><a href="#2，作用域" class="headerlink" title="2，作用域"></a>2，作用域</h3><h4 id="2-1-命名空间"><a href="#2-1-命名空间" class="headerlink" title="2.1 命名空间"></a>2.1 命名空间</h4><p>禁止使用using</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cc 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义都置于命名空间中</span></span><br><span class="line"><span class="keyword">void</span> MyClass::Foo() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure><h4 id="2-2-匿名命名空间"><a href="#2-2-匿名命名空间" class="headerlink" title="2.2 匿名命名空间"></a>2.2 匿名命名空间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;  <span class="comment">// 匿名命名空间，编译器自动生成唯一名字</span></span><br></pre></td></tr></table></figure><p>推荐、鼓励在 <code>.cc</code> 中对于不需要在其他地方引用的标识符使用<strong>内部链接性声明</strong> （匿名命名空间和static），但是不要在 <code>.h</code> 中使用。</p><p>所有置于匿名命名空间的声明都具有内部链接性，名称的作用域被限制在当前文件中，无法通过在另外的文件中使用extern声明来进行链接</p><p>函数和变量可以经由声明为 <code>static</code> 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p><h4 id="2-3-静态成员函数与命名空间非成员函数"><a href="#2-3-静态成员函数与命名空间非成员函数" class="headerlink" title="2.3 静态成员函数与命名空间非成员函数"></a>2.3 静态成员函数与命名空间非成员函数</h4><p><strong>尽量不要使用全局函数，非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内，不要使用静态成员方法，类的静态方法应当和类的实例或静态数据紧密相关.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;  <span class="comment">//非成员函数应置于命名空间中</span></span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><h4 id="2-4-将函数变量尽可能置于最小作用域内-并在变量声明时进行初始化-离第一次使用越近越好"><a href="#2-4-将函数变量尽可能置于最小作用域内-并在变量声明时进行初始化-离第一次使用越近越好" class="headerlink" title="2.4 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化,离第一次使用越近越好"></a>2.4 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化,离第一次使用越近越好</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Not Like This</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = f(); <span class="comment">// 坏——初始化和声明分离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Better Like This</span></span><br><span class="line"><span class="keyword">int</span> j = g(); <span class="comment">// 好——初始化时声明</span></span><br></pre></td></tr></table></figure><p>if, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">'/'</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>有一个例外, 如果<strong>变量是一个对象</strong>, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低，这时应该在循环作用域外面声明这类变量:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.DoSomething(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.DoSomething(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-静态和全局变量"><a href="#2-5-静态和全局变量" class="headerlink" title="2.5 静态和全局变量"></a>2.5 静态和全局变量</h4><p>尽量不用全局函数和全局变量,</p><p>多线程中的全局变量 (含静态成员变量) 不要使用 <code>class</code> 类型 (含 STL 容器), 因为构造和析构顺序的不确定导致不明确行为导致的 bug.</p><p>静态生存周期的对象，即包括了<strong>全局变量，静态变量，静态类成员变量和函数静态变量</strong>，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。即<strong>完全禁用类类型的全局变量</strong>，比如vector(使用 C 数组替代) 和string(使用 <code>const char []</code>)。我们也<strong>不允许用函数返回值来初始化 POD 变量</strong>，除非该函数不涉及任何全局变量。</p><h3 id="3，类"><a href="#3，类" class="headerlink" title="3，类"></a>3，类</h3><h4 id="3-1-不要在构造函数中调用虚函数"><a href="#3-1-不要在构造函数中调用虚函数" class="headerlink" title="3.1 不要在构造函数中调用虚函数"></a>3.1 不要在构造函数中调用虚函数</h4><p>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</p><h4 id="3-2-对于单参数构造函数-请使用explicit关键字来禁止隐式转换"><a href="#3-2-对于单参数构造函数-请使用explicit关键字来禁止隐式转换" class="headerlink" title="3.2 对于单参数构造函数, 请使用explicit关键字来禁止隐式转换"></a>3.2 对于单参数构造函数, 请使用explicit关键字来禁止隐式转换</h4><h4 id="3-3-移动构造函数，移动赋值函数和拷贝构造函数，拷贝赋值函数"><a href="#3-3-移动构造函数，移动赋值函数和拷贝构造函数，拷贝赋值函数" class="headerlink" title="3.3 移动构造函数，移动赋值函数和拷贝构造函数，拷贝赋值函数"></a>3.3 移动构造函数，移动赋值函数和拷贝构造函数，拷贝赋值函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassName()&#123;&#125;     <span class="comment">//构造函数</span></span><br><span class="line">    ClassName(<span class="keyword">int</span> x)&#123;&#125;  <span class="comment">//有参数的构造函数</span></span><br><span class="line">    ~ClassName()&#123;<span class="keyword">delete</span> *a&#125;  <span class="comment">//析构函数</span></span><br><span class="line">    </span><br><span class="line">    ClassName(<span class="keyword">const</span> ClassName &amp;Obj)&#123;&#125; <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ClaaName&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ClassName &amp;Obj)&#123;  <span class="comment">//拷贝赋值函数</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ClassName(ClassName &amp;&amp;Obj)&#123;&#125;   <span class="comment">//移动构造函数</span></span><br><span class="line">    ClassName&amp; <span class="keyword">operator</span>=(ClassName &amp;Obj)&#123;  <span class="comment">//移动赋值函数</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-3-1-拷贝构造函数"><a href="#3-3-1-拷贝构造函数" class="headerlink" title="3.3.1 拷贝构造函数:"></a>3.3.1 <strong>拷贝构造函数:</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass foo;</span><br><span class="line"><span class="function">MyClass <span class="title">bar</span><span class="params">(foo)</span></span>;       <span class="comment">// 对象初始化: 调用拷贝构造函数</span></span><br><span class="line">MyClass baz = foo;      <span class="comment">// 对象初始化: 调用拷贝构造函数</span></span><br><span class="line">foo = bar;              <span class="comment">// 对象已经被初始化，调用拷贝赋值</span></span><br></pre></td></tr></table></figure><p>什么时候用到拷贝构造函数？  </p><ol><li>一个对象以值传递的方式传入函数体；</li><li>一个对象以值传递的方式从函数返回； </li><li>一个对象需要通过另外一个对象进行初始化</li></ol><h5 id="3-3-2-深拷贝"><a href="#3-3-2-深拷贝" class="headerlink" title="3.3.2 深拷贝"></a>3.3.2 <strong>深拷贝</strong></h5><p>如果一个类拥有资源，当这个类的对象发生复制过程的时候，<strong>资源重新分配</strong>，例如需要新开辟内存，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p><p>如对象A=B。这时，如果B中有一个成员变量指针已经申请了内存，浅拷贝(默认拷贝构造函数)则是A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</p><h5 id="3-3-3-移动构造函数"><a href="#3-3-3-移动构造函数" class="headerlink" title="3.3.3 移动构造函数"></a>3.3.3 <strong>移动构造函数</strong></h5><p>移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。  这里未命名的对象就是那些临时变量，甚至都不会有名称。</p><p>典型的未命名对象就是<strong>函数的返回值或者类型转换的对象</strong>。  </p><p>使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">fn</span><span class="params">()</span></span>;            <span class="comment">// 函数返回一个 MyClass 对象</span></span><br><span class="line">MyClass foo;             <span class="comment">// 默认构造函数</span></span><br><span class="line">MyClass bar = foo;       <span class="comment">// 拷贝构造函数</span></span><br><span class="line">MyClass baz = fn();      <span class="comment">// 移动构造函数</span></span><br><span class="line">foo = bar;               <span class="comment">// 拷贝赋值</span></span><br><span class="line">baz = MyClass();         <span class="comment">// 移动赋值</span></span><br></pre></td></tr></table></figure><h5 id="3-3-4-区别"><a href="#3-3-4-区别" class="headerlink" title="3.3.4 区别:"></a>3.3.4 <strong>区别:</strong></h5><p>拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。  而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。</p><h5 id="3-3-5-总结"><a href="#3-3-5-总结" class="headerlink" title="3.3.5 总结"></a>3.3.5 总结</h5><p>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.</p><p>如果你的类不需要拷贝 / 移动操作, 请显式地通过在 <code>public</code> 域中使用 <code>= delete</code> 或其他手段禁用之.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable.</span></span><br><span class="line">MyClass(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h4 id="3-4-仅当只有数据成员时使用struct，其它一概使用class"><a href="#3-4-仅当只有数据成员时使用struct，其它一概使用class" class="headerlink" title="3.4 仅当只有数据成员时使用struct，其它一概使用class"></a>3.4 仅当只有数据成员时使用struct，其它一概使用class</h4><h4 id="3-5-继承"><a href="#3-5-继承" class="headerlink" title="3.5 继承"></a>3.5 继承</h4><p>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承</p><h5 id="3-5-1-组合"><a href="#3-5-1-组合" class="headerlink" title="3.5.1 组合"></a>3.5.1 组合</h5><p>组合类：一个类(Head类)里面的数据成员是另一个类的对象，即内嵌其他类的对象作为自己的成员。</p><p>Eye,Nose,Mouth,Ear这些类都是Head类的一部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Eye&#123;void look()&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nose</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouth</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ear</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Head</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">look</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_eye.look()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Eye m_eye;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果A类是B类的一部分，则不要让B类去继承A类，而是采用组合的形式。如果A类和B类毫无关系，我们不应该为了让B类多一个功能而去让B继承A。如果在逻辑上B是A的一种，即B类的man也是A类的 Hunman的一种我们就可以让B类去继承A类。</p><h5 id="3-5-2-继承"><a href="#3-5-2-继承" class="headerlink" title="3.5.2 继承"></a>3.5.2 继承</h5><p>所有继承必须是 <code>public</code> 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.</p><p>对于可能被子类访问的成员函数, 不要过度使用 <code>protected</code> 关键字.</p><p>数据成员都必须是 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#access-control" target="_blank" rel="noopener">私有的</a>.</p><p>#####　3.5.3 虚函数</p><p>能够根据<strong>指针</strong>所指类型调用对应的类对象，实现函数调用时的多态性。</p><p>虚函数必须声明是指针才有多态，即基类的指针指向了子类的对象，虚函数调用的是子类对象的函数，不是虚函数则调用的是基类对象的函数。</p><p>基类的析构函数应该是虚函数。</p><p>派生类对象构造的时候先调用基类的构造函数再调用派生类的构造函数，析构的时候先调用派生类析构函数再调用基类析构函数。派生类的析构函数会只析构自己的那部分，这时候如果基类的析构函数不是虚函数，则不能调用基类的析构函数析构从基类继承来的那部分成员，所以就会出现只删一半的现象，造成内存泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不管析构函数是否是虚函数(即是否加virtual关键词)，delete时基类和子类都会被释放；</span></span><br><span class="line">SubClass* pObj = <span class="keyword">new</span> SubClass(); <span class="comment">//子类指针指向子类对象</span></span><br><span class="line"><span class="keyword">delete</span> pObj; <span class="comment">//析构时，调用的子类的析构，即子类的析构函数，先析构子类再析构基类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BaseClass* pObj = <span class="keyword">new</span> SubClass(); <span class="comment">//基类指针指向子类对象，</span></span><br><span class="line">pObj-&gt;dosomething();<span class="comment">//如果dosomething()是虚函数,则调用的是子类dosomething()函数;如果dosomething()不是虚函数，则该语句调用的是基类的dosomething()函数</span></span><br><span class="line"><span class="keyword">delete</span> pObj;</span><br><span class="line"><span class="comment">//若析构函数是虚函数(即加上virtual关键词)，delete时基类和子类都会被释放；</span></span><br><span class="line"><span class="comment">//若析构函数不是虚函数(即不加virtual关键词)，delete时只释放基类，不释放子类；</span></span><br></pre></td></tr></table></figure><h4 id="3-6-声明顺序"><a href="#3-6-声明顺序" class="headerlink" title="3.6 声明顺序"></a>3.6 声明顺序</h4><p>类定义一般应以 <code>public:</code> 开始, 后跟 <code>protected:</code>, 最后是 <code>private:</code>. 省略空部分.</p><p>在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: </p><ul><li>类型 (包括 <code>typedef</code>, <code>using</code>和嵌套的结构体与类),</li><li>常量</li><li>工厂函数</li><li>构造函数</li><li>赋值运算符</li><li>析构函数</li><li>其他函数</li><li>数据成员</li></ul><p>不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中</p><h3 id="4，函数"><a href="#4，函数" class="headerlink" title="4，函数"></a>4，函数</h3><h4 id="4-1-参数顺序"><a href="#4-1-参数顺序" class="headerlink" title="4.1 参数顺序"></a>4.1 参数顺序</h4><p>函数的参数顺序为: 输入参数在先, 后跟输出参数.</p><h4 id="4-2-函数长度"><a href="#4-2-函数长度" class="headerlink" title="4.2 函数长度"></a>4.2 函数长度</h4><p>如果函数超过 <strong>40 行</strong>, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p><h4 id="4-3-引用参数"><a href="#4-3-引用参数" class="headerlink" title="4.3 引用参数"></a>4.3 引用参数</h4><p>所有按引用传递的参数必须加上 <code>const</code>。</p><p>输入参数是值参或 <code>const</code> 引用，输入参数可以是 <code>const</code> 指针，但决不能是非 <code>const</code> 的引用参数</p><p>输出参数为指针. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;in, <span class="built_in">string</span> *out)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="4-4-函数重载"><a href="#4-4-函数重载" class="headerlink" title="4.4 函数重载"></a>4.4 函数重载</h4><p>如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 <code>AppendString()</code> 和 <code>AppendInt()</code> 等, 而不是一口气重载多个 <code>Append()</code>. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 <code>std::vector</code> 以便使用者可以用 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#braced-initializer-list" target="_blank" rel="noopener">列表初始化</a> 指定参数. </p><h3 id="5，其他"><a href="#5，其他" class="headerlink" title="5，其他"></a>5，其他</h3><h4 id="5-1-使用-C-的类型转换-如-static-cast-lt-gt-不要使用int-y-int-x等转换方式"><a href="#5-1-使用-C-的类型转换-如-static-cast-lt-gt-不要使用int-y-int-x等转换方式" class="headerlink" title="5.1 使用 C++ 的类型转换, 如 static_cast&lt;&gt;(). 不要使用int y = (int)x等转换方式"></a>5.1 使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用int y = (int)x等转换方式</h4><h4 id="5-2-禁止使用-RTTI"><a href="#5-2-禁止使用-RTTI" class="headerlink" title="5.2 禁止使用 RTTI."></a>5.2 禁止使用 RTTI.</h4><h4 id="5-3-不使用-C-异常"><a href="#5-3-不使用-C-异常" class="headerlink" title="5.3 不使用 C++ 异常."></a>5.3 不使用 C++ 异常.</h4><h4 id="5-4-只在记录日志时使用流"><a href="#5-4-只在记录日志时使用流" class="headerlink" title="5.4 只在记录日志时使用流."></a>5.4 只在记录日志时使用流.</h4><p>不要使用流, 除非是日志接口需要. 使用 <code>printf</code> 之类的代替.</p><h4 id="5-5-对于迭代器和其他模板对象使用前缀形式-i-的自增-自减运算符"><a href="#5-5-对于迭代器和其他模板对象使用前缀形式-i-的自增-自减运算符" class="headerlink" title="5.5 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符."></a>5.5 对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增, 自减运算符.</h4><p>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减)，不考虑返回值的话, 前置自增 (<code>++i</code>) 通常要比后置自增 (<code>i++</code>) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 <code>i</code> 进行一次拷贝. 如果 <code>i</code> 是迭代器或其他非数值类型, 拷贝的代价是比较大的.</p><h4 id="5-6-const"><a href="#5-6-const" class="headerlink" title="5.6 const"></a>5.6 const</h4><p>const变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误.</p><p>注意初始化 const 对象时，必须在初始化的同时值初始化。</p><p> <strong>我们强烈建议在任何可能的情况下使用 const</strong></p><ul><li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 <code>const</code>.</li><li>尽可能将函数声明为 <code>const</code>. 访问函数应该总是 <code>const</code>. 其他不会修改任何数据成员, 未调用非 <code>const</code> 函数, 不会返回数据成员非 <code>const</code> 指针或引用的函数也应该声明成 <code>const</code>.</li><li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 <code>const</code>.</li></ul><h4 id="5-7-constexpr"><a href="#5-7-constexpr" class="headerlink" title="5.7 constexpr"></a>5.7 constexpr</h4><p>变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 constexpr, 以用来定义 constexpr 变量</p><h4 id="5-8-预处理宏"><a href="#5-8-预处理宏" class="headerlink" title="5.8 预处理宏"></a>5.8 预处理宏</h4><p>用宏展开性能关键的代码, 现在可以用<strong>内联函数</strong>替代. </p><p>用宏表示常量可被<strong>const变量</strong>代替. </p><p>用宏 “缩写” 长变量名可被<strong>引用</strong>代替.</p><p>使用宏时，应遵守：</p><ul><li>不要在 <code>.h</code> 文件中定义宏.</li><li>在马上要使用时才进行 <code>#define</code>, 使用后要立即 <code>#undef</code>.</li><li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li><li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li><li>不要用 <code>##</code> 处理函数，类和变量的名字。</li></ul><h4 id="5-9-零值"><a href="#5-9-零值" class="headerlink" title="5.9 零值"></a>5.9 零值</h4><p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用 <code>&#39;\0&#39;</code>.</p><h4 id="5-10-尽可能用-sizeof-varname-代替-sizeof-type"><a href="#5-10-尽可能用-sizeof-varname-代替-sizeof-type" class="headerlink" title="5.10 尽可能用 sizeof(varname) 代替 sizeof(type)."></a>5.10 尽可能用 <code>sizeof(varname)</code> 代替 <code>sizeof(type)</code>.</h4><h3 id="6，命名规范"><a href="#6，命名规范" class="headerlink" title="6，命名规范"></a>6，命名规范</h3><h4 id="6-1-文件命名"><a href="#6-1-文件命名" class="headerlink" title="6.1 文件命名"></a>6.1 文件命名</h4><p>文件名要全部小写, 可以包含下划线 (<code>_</code>) </p><h4 id="6-2-类型命名"><a href="#6-2-类型命名" class="headerlink" title="6.2 类型命名"></a>6.2 类型命名</h4><p>类型名称的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code></p><h4 id="6-3-变量命名"><a href="#6-3-变量命名" class="headerlink" title="6.3 变量命名"></a>6.3 变量命名</h4><p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接，</p><p><strong>类的成员变量以下划线结尾</strong>，但结构体的就不用。</p><p>如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>.</p><h4 id="6-4-常量命名"><a href="#6-4-常量命名" class="headerlink" title="6.4 常量命名"></a>6.4 常量命名</h4><p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以<strong>k</strong>开头, 大小写混合. 例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h4 id="6-5-函数命名"><a href="#6-5-函数命名" class="headerlink" title="6.5 函数命名"></a>6.5 函数命名</h4><p>一般来说, 函数名的每个单词首字母大写，没有下划线。</p><p>对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 <code>StartRpc()</code> 而非 <code>StartRPC()</code>).</p><h4 id="6-6-命名空间"><a href="#6-6-命名空间" class="headerlink" title="6.6 命名空间"></a>6.6 命名空间</h4><p>命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p><p>顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p><p>注意 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#general-naming-rules" target="_blank" rel="noopener">不使用缩写作为名称</a> 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.</p><h3 id="7，格式"><a href="#7，格式" class="headerlink" title="7，格式"></a>7，格式</h3><h4 id="7-1-每一行代码字符数不超过-80"><a href="#7-1-每一行代码字符数不超过-80" class="headerlink" title="7.1 每一行代码字符数不超过 80."></a>7.1 每一行代码字符数不超过 80.</h4><h4 id="7-2-尽量不使用非-ASCII-字符-使用时必须使用-UTF-8-编码"><a href="#7-2-尽量不使用非-ASCII-字符-使用时必须使用-UTF-8-编码" class="headerlink" title="7.2 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码."></a>7.2 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</h4><h4 id="7-3-函数声明与调用"><a href="#7-3-函数声明与调用" class="headerlink" title="7.3 函数声明与调用"></a>7.3 函数声明与调用</h4><p>返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#function-calls" target="_blank" rel="noopener">函数调用</a> 一致.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同一行文本太多, 放不下所有参数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,</span><br><span class="line">                                             Type par_name3) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReturnType LongClassName::ReallyReallyReallyLongFunctionName(</span><br><span class="line">    Type par_name1,  <span class="comment">// 4 space indent</span></span><br><span class="line">    Type par_name2,</span><br><span class="line">    Type par_name3) &#123;</span><br><span class="line">  DoSomething();  <span class="comment">// 2 space indent</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>使用好的参数名.</li><li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li><li>如果返回类型和函数名在一行放不下, 分行.</li><li>如果返回类型与函数声明或定义分行了, 不要缩进.</li><li>左圆括号总是和函数名在同一行.</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li><li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li><li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li><li>右圆括号和左大括号间总是有一个空格.</li><li>所有形参应尽可能对齐.</li><li>缺省缩进为 2 个空格.</li><li>换行后的参数保持 4 个空格的缩进.</li></ul><h4 id="7-4-条件语句"><a href="#7-4-条件语句" class="headerlink" title="7.4 条件语句"></a>7.4 条件语句</h4><p>注意所有情况下 <code>if</code> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( condition ) &#123;  <span class="comment">// 圆括号与空格紧邻 - 不常见</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( condition2 ) &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-循环语句与switch"><a href="#7-5-循环语句与switch" class="headerlink" title="7.5 循环语句与ｓｗｉｔｃｈ"></a>7.5 循环语句与ｓｗｉｔｃｈ</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></span><br><span class="line">    ...      <span class="comment">// 4 空格缩进</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 反复循环直到条件失效.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体.</span></span><br><span class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑.</span></span><br></pre></td></tr></table></figure><h4 id="7-6-指针与引用"><a href="#7-6-指针与引用" class="headerlink" title="7.6 指针与引用"></a>7.6 指针与引用</h4><p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*, &amp;</code>) 之后不能有空格.</p><ul><li>在访问成员时, 句点或箭头前后没有空格.</li><li>指针操作符 <code>*</code> 或 <code>&amp;</code> 后没有空格.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">x = r.y;</span><br><span class="line">x = r-&gt;y;</span><br><span class="line"><span class="comment">// 好, 空格前置.</span></span><br><span class="line"><span class="keyword">char</span> *c;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好, 空格后置.</span></span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, *y;  <span class="comment">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span></span><br><span class="line"><span class="keyword">char</span> * c;  <span class="comment">// 差 - * 两边都有空格</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp; str;  <span class="comment">// 差 - &amp; 两边都有空格.</span></span><br></pre></td></tr></table></figure><h4 id="7-7-变量与数组初始化"><a href="#7-7-变量与数组初始化" class="headerlink" title="7.7 变量与数组初始化"></a>7.7 变量与数组初始化</h4><p>用 <code>=</code>, <code>()</code> 和 <code>{}</code> 均可.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"Some Name"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"Some Name"</span>;</span><br><span class="line"><span class="built_in">string</span> name&#123;<span class="string">"Some Name"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">100</span>, <span class="number">1</span>);  <span class="comment">// 内容为 100 个 1 的向量.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">100</span>, <span class="number">1</span>&#125;;  <span class="comment">// 内容为 100 和 1 的向量.</span></span><br></pre></td></tr></table></figure><h4 id="7-8-类格式"><a href="#7-8-类格式" class="headerlink" title="7.8 类格式"></a>7.8 类格式</h4><p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每个都缩进 1 个空格.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> OtherClass &#123;</span><br><span class="line"> <span class="keyword">public</span>:      <span class="comment">// 注意有一个空格的缩进</span></span><br><span class="line">  MyClass();  <span class="comment">// 标准的两空格缩进</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</span><br><span class="line">  ~MyClass() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_some_var</span><span class="params">(<span class="keyword">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">some_var</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> some_var_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SomeInternalFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> some_var_;</span><br><span class="line">  <span class="keyword">int</span> some_other_var_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li><li>关键词 <code>public:</code>, <code>protected:</code>, <code>private:</code> 要缩进 1 个空格.</li><li>除第一个关键词 (一般是 <code>public</code>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li><li>这些关键词后不要保留空行.</li><li><code>public</code> 放在最前面, 然后是 <code>protected</code>, 最后是 <code>private</code>.</li><li>关于声明顺序的规则请参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#declaration-order" target="_blank" rel="noopener">声明顺序</a> 一节.</li></ul><h4 id="7-9-初始化列表"><a href="#7-9-初始化列表" class="headerlink" title="7.9 初始化列表"></a>7.9 初始化列表</h4><p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var) : some_var_(var) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var), some_other_var_(var + <span class="number">1</span>) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var),             <span class="comment">// 4 space indent</span></span><br><span class="line">      some_other_var_(var + <span class="number">1</span>) &#123;  <span class="comment">// lined up</span></span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行</span></span><br><span class="line"><span class="comment">// 如果这样做合适的话</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="7-10-命名空间"><a href="#7-10-命名空间" class="headerlink" title="7.10 命名空间"></a>7.10 命名空间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 正确. 命名空间内没有额外的缩进.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不要在命名空间内缩进</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错, 缩进多余了.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><p>通用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前总是有空格.</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格.</span></span><br><span class="line"><span class="comment">// 列表初始化中大括号内的空格是可选的.</span></span><br><span class="line"><span class="comment">// 如果加了空格, 那么两边都要加上.</span></span><br><span class="line"><span class="keyword">int</span> x[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 对于单行函数的实现, 在大括号内加上空格</span></span><br><span class="line">  <span class="comment">// 然后是函数实现</span></span><br><span class="line">  Foo(<span class="keyword">int</span> b) : Bar(), baz_(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话, 不加空格.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用括号把大括号与实现分开.</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> ( i ) &#123;    <span class="comment">// 循环和条件语句的圆括号里可以与空格紧邻.</span></span><br><span class="line"><span class="keyword">if</span> ( test ) &#123;     <span class="comment">// 圆括号, 但这很少见. 总之要一致.</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格.</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码, 加个空格.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符前后总是有空格.</span></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span></span><br><span class="line"><span class="comment">// 圆括号内部没有紧邻空格.</span></span><br><span class="line">v = w * x + y / z;</span><br><span class="line">v = w*x + y/z;</span><br><span class="line">v = w * (x + z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在参数和一元操作符之间不加空格.</span></span><br><span class="line">x = <span class="number">-5</span>;</span><br><span class="line">++x;</span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; x;</span><br><span class="line">y = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span> *&gt; x;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Google编程规范：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;Google的C++开源项目编程规范&lt;br&gt;
    
    </summary>
    
      <category term="基础学习" scheme="https://itsma.github.io/categories/Base/"/>
    
    
      <category term="Base" scheme="https://itsma.github.io/tags/Base/"/>
    
  </entry>
  
  <entry>
    <title>catkin_make ERROR</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/catkinerror.html"/>
    <id>https://itsma.github.io/[object Object]/catkinerror.html</id>
    <published>2018-07-16T02:12:38.000Z</published>
    <updated>2018-08-01T09:00:37.881Z</updated>
    
    <content type="html"><![CDATA[<p><strong> catkin_make ERROR：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>编写完节点源代码后，catkin-make编译包时出现的错误分析。<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="CMakelist-txt参数"><a href="#CMakelist-txt参数" class="headerlink" title="CMakelist.txt参数"></a>CMakelist.txt参数</h2><h3 id="project"><a href="#project" class="headerlink" title="project()"></a>project()</h3><p>包的名字，根据catkin_create_pkg后面的名字命名。注意需要与后面的参数对准。</p><h3 id="find-package"><a href="#find-package" class="headerlink" title="find_package()"></a>find_package()</h3><p>编译包需要的依赖项。可以自己添加。格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS //必须的</span><br><span class="line">  x  //根据自己编写的源代码需要的依赖项</span><br><span class="line">  y</span><br><span class="line">  z</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories()"></a>include_directories()</h3><p>如果包有头文件，需要注意该选项。格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">  include $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="add-executable"><a href="#add-executable" class="headerlink" title="add_executable()"></a>add_executable()</h3><p>指定编译的文件，以及要生成的可执行文件，即节点。需要注意的是，自动生成的CMakelist文件中，会自动把节点和源文件等命名为xxx_node的格式，需要修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable($&#123;PROJECT_NAME&#125;_node src/mynode_node.cpp) //自动生成的</span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125; src/main.cpp src/file1.cpp src/file2.cpp) //正确编译的</span><br></pre></td></tr></table></figure><p>将调用src/main.cpp，src/file1.cpp和src/file2.cpp生成名为myNode的目标可执行文件</p><h3 id="target-link-libraries"><a href="#target-link-libraries" class="headerlink" title="target_link_libraries()"></a>target_link_libraries()</h3><p>指定生成的可执行文件需要链接的库文件。格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125;_node</span><br><span class="line">                      $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="错误1-Undefined-reference-to-‘’ros-init-’’"><a href="#错误1-Undefined-reference-to-‘’ros-init-’’" class="headerlink" title="错误1:Undefined reference to ‘’ros::init()’’"></a>错误1:Undefined reference to ‘’ros::init()’’</h2><p>出现该编译错误的原因很可能是</p><ul><li>头文件问题</li><li>CMakelist.txt问题</li></ul><h3 id="头文件问题"><a href="#头文件问题" class="headerlink" title="头文件问题"></a>头文件问题</h3><p>检查包含的头文件，有可能写错。</p><h3 id="CMakelist-txt问题"><a href="#CMakelist-txt问题" class="headerlink" title="CMakelist.txt问题"></a>CMakelist.txt问题</h3><p>主要检查以下几个方面：project名字，依赖包是否完整，头文件夹是否包含，</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; catkin_make ERROR：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;编写完节点源代码后，catkin-make编译包时出现的错误分析。&lt;br&gt;
    
    </summary>
    
      <category term="ROS学习" scheme="https://itsma.github.io/categories/ROS/"/>
    
    
      <category term="ROS" scheme="https://itsma.github.io/tags/ROS/"/>
    
  </entry>
  
</feed>
