<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ITS&#39;Ma Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://itsma.github.io/"/>
  <updated>2018-09-05T06:07:25.235Z</updated>
  <id>https://itsma.github.io/</id>
  
  <author>
    <name>ITS-Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DFS和BFS</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/dfsandbfs.html"/>
    <id>https://itsma.github.io/[object Object]/dfsandbfs.html</id>
    <published>2018-09-03T01:29:32.000Z</published>
    <updated>2018-09-05T06:07:25.235Z</updated>
    
    <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""><p>当题目看不出任何规律，既不能用分治，贪心，也不能用动规时，这时候万能方法——搜索， 就派上用场了。搜索分为广搜BFS和深搜DFS。解决<strong>多阶段最优化问题。</strong></p><p>广搜里面又有普通广搜，双向广搜，A*搜索等。 </p><p>深搜里面又有普通深搜，回溯法等。</p><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="广度优先遍历BFS"><a href="#广度优先遍历BFS" class="headerlink" title="广度优先遍历ＢＦＳ"></a>广度优先遍历ＢＦＳ</h2><h3 id="思考步骤"><a href="#思考步骤" class="headerlink" title="思考步骤"></a>思考步骤</h3><h4 id="求解目标"><a href="#求解目标" class="headerlink" title="求解目标"></a>求解目标</h4><p>求解路径长度，还是路径？</p><ol><li>如果是求路径长度，则状态里面要存路径长度（或双队列+一个全局变量）</li><li>如果是求路径本身或动作序列<ol><li>要用一棵树存储宽搜过程中的路径</li><li>是否可以预估状态个数的上限？能够预估状态总数，则开一个大数组，用树的双亲表示法；如果不能预估状态总数，则要使用一棵通用的树。这一步也是第4步的必要不充分条件</li></ol></li></ol><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p>即一个状态需要存储哪些些必要的数据，才能够完整提供如何扩展到下一步状态的所有信息。一般记录当前位置或整体局面。</p><h4 id="状态扩展"><a href="#状态扩展" class="headerlink" title="状态扩展"></a>状态扩展</h4><p>这一步跟第2步相关。状态里记录的数据不同，扩展方法就不同。对于固定不变的数据结构（一般题目直接给出，作为输入数据），如二叉树，图等，扩展方法很简单，直接往下一层走，对于隐式图，要先在第1步里想清楚状态所带的数据，想清楚了这点，那如何扩展就很简单了。</p><h4 id="判断状态重复"><a href="#判断状态重复" class="headerlink" title="判断状态重复"></a>判断状态重复</h4><p>如果状态转换图是一颗树，则永远不会出现回路，不需要判重；如果状态转换图是一个图（这时候是一个图上的BFS），则需要判重。</p><ol><li>如果是求最短路径长度或一条路径，则只需要让“点”（即状态）不重复出现，即可保证不出现回路</li><li>如果是求所有路径，注意此时，状态转换图是DAG，即允许两个父节点指向同一个子节点。具体实现时，每个节点要<strong>“延迟”</strong>加入到已访问集合<code>visited</code>，要等一层全部访问完后，再加入到<code>visited</code>集合。</li><li>具体实现<ul><li>状态是否存在完美哈希方案？即将状态一一映射到整数，互相之间不会冲突。</li><li>如果不存在，则需要使用通用的哈希表（自己实现或用标准库，例如<code>unordered_set</code>）来判重；自己实现哈希表的话，如果能够预估状态个数的上限，则可以开两个数组，head和next，表示哈希表。</li><li>如果存在，则可以开一个大布尔数组，来判重，且此时可以精确计算出状态总数，而不仅仅是预估上限</li></ul></li></ol><h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>广搜ＢＦＳ需要</p><p>一个<strong>队列</strong>，用于一层一层扩展；</p><p>一个<strong>hashset</strong>，用于判重；</p><p>一棵<strong>树</strong>（只求长度时不需要），用于存储整棵树。</p><p>对于队列，可以用<code>queue</code>，也可以把<code>vector</code>当做队列使用。当求长度时，有两种做法：</p><ol><li>只用一个队列，但在状态结构体<code>state_t</code>里增加一个整数字段<code>level</code>，表示当前所在的层次，当碰到目标状态，直接输出<code>level</code>即可。这个方案，可以很容易的变成A*算法，把<code>queue</code>替换为<code>priority_queue</code>即可。</li><li>用两个队列，<code>current, next</code>，分别表示当前层次和下一层，另设一个全局整数<code>level</code>，表示层数（也即路径长度），当碰到目标状态，输出<code>level</code>即可。这个方案，状态里可以不存路径长度，只需全局设置一个整数<code>level</code>，比较节省内存；</li></ol><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>wordladder</p><p>Given two words (start and end), and a dictionary, find the length of shortest transformation sequence from start to end, such that:</p><ul><li>Only one letter can be changed at a time</li><li>Each intermediate word must exist in the dictionary</li></ul><p>for example</p><p>start = “hit”<br>end = “cog”<br>dict = [“hot”,”dot”,”dog”,”lot”,”log”]</p><p>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”, return its length 5</p><p>Note:<br>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//定义状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line">state(<span class="built_in">string</span> s, <span class="keyword">int</span> lvl) :word(s), level(lvl) &#123;&#125;</span><br><span class="line">&#125;state;</span><br><span class="line"><span class="comment">//在字典中存在且与目标有相同元素则是可用的</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsValid</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">const</span> <span class="built_in">string</span> endWord, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dict.find(s) == dict.end())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.size(); ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == endWord[i])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> &amp;a, <span class="keyword">char</span> &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthofladder</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> beginWord, <span class="keyword">const</span> <span class="built_in">string</span> endWord, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (beginWord.size() != endWord.size())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (beginWord.size() == <span class="number">0</span> || dict.empty())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = beginWord.size();</span><br><span class="line"><span class="keyword">int</span> minlength = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;state&gt; nextstate;<span class="comment">//表示状态队列</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; visited; <span class="comment">//表示已经转换过的词语</span></span><br><span class="line"><span class="function">state <span class="title">head</span><span class="params">(beginWord, <span class="number">1</span>)</span></span>;</span><br><span class="line">nextstate.push(head);</span><br><span class="line"><span class="comment">//state *node=nullptr;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!nextstate.empty()) &#123;</span><br><span class="line">state node = nextstate.front();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; node.word &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">visited.insert(node.word);</span><br><span class="line">nextstate.pop();</span><br><span class="line"><span class="built_in">string</span> str = node.word;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;str.size(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (c == str[i])<span class="keyword">continue</span>;</span><br><span class="line">swap(c, str[i]);</span><br><span class="line"><span class="keyword">if</span> (visited.find(str) != visited.end())<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (str == endWord) &#123; <span class="comment">//要求最短的路径</span></span><br><span class="line"><span class="keyword">return</span> (minlength &gt; node.level + <span class="number">1</span> ? node.level + <span class="number">1</span> : minlength);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (IsValid(str, endWord, dict)) &#123;</span><br><span class="line"><span class="function">state <span class="title">newWord</span><span class="params">(str, node.level + <span class="number">1</span>)</span></span>;</span><br><span class="line">nextstate.push(newWord);</span><br><span class="line">&#125;</span><br><span class="line">swap(c, str[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> begin = <span class="string">"hit"</span>;</span><br><span class="line"><span class="built_in">string</span> end = <span class="string">"cog"</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vec = &#123; <span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"sit"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span> ,<span class="string">"cog"</span>&#125;;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; d(vec.begin(), vec.end());</span><br><span class="line"><span class="keyword">int</span> x = lengthofladder(begin, end, d);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>set没有push方法，添加元素只有insert方法。</p><p>queue没有insert方法，需要push。也没有top方法，只有front方法和back方法。</p><h2 id="深度优先遍历DFS"><a href="#深度优先遍历DFS" class="headerlink" title="深度优先遍历ＤＦＳ"></a>深度优先遍历ＤＦＳ</h2><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>求解目标：多阶段存在性问题。<strong>必须要走到最深（例如对于树，必须要走到叶子节点）才能得到一个解，</strong>这种情况适合用深搜。</p><h3 id="思考步骤-1"><a href="#思考步骤-1" class="headerlink" title="思考步骤"></a>思考步骤</h3><p>１，问题类型</p><p>深搜最常见的三个问题，求可行解的总数，求一个可行解，求所有可行解。<br>如果是路径条数，则不需要存储路径。<br>如果是求路径本身，则要用一个数组path[]存储路径。跟宽搜不同，宽搜虽然最终求的也是一条路径，但是需要存储扩展过程中的所有路径，在没找到答案之前所有路径都不能放弃；而深搜，在搜索过程中始终只有一条路径，因此用一个数组就足够了</p><p>２，求解个数</p><p>只要求一个解，还是要求所有解？如果只要求一个解，那找到一个就可以返回；如果要求所有解，找到了一个后，还要继续扩展，直到遍历完。广搜一般只要求一个解，因而不需要考虑这个问题</p><p>３，状态表示</p><p>如何表示状态？即一个状态需要存储哪些些必要的数据，才能够完整提供如何扩展到下一步状态的所有信息。跟广搜不同，深搜的惯用写法，<strong>不是把数据记录在状态struct里，而是添加函数参数（有时为了节省递归堆栈，用全局变量），</strong>struct里的字段与函数参数一一对应。</p><p>４，扩展状态</p><p>如何扩展状态？这一步跟上一步相关。状态里记录的数据不同，扩展方法就不同。对于固定不变的数据结构（一般题目直接给出，作为输入数据），如二叉树，图等，扩展方法很简单，直接往下一层走，对于隐式图，要先在第1步里想清楚状态所带的数据，想清楚了这点，那如何扩展就很简单了</p><p>５，终止条件</p><p>终止条件是什么？终止条件是指到了不能扩展的末端节点。对于树，是叶子节点，对于图或隐式图，是出度为0的节点。</p><p>６，收敛条件</p><p>收敛条件是什么？收敛条件是指找到了一个合法解的时刻。如果是正向深搜（父状态处理完了才进行递归，即父状态不依赖子状态，递归语句一定是在最后，尾递归），则是指是否达到目标状态；如果是逆向深搜（处理父状态时需要先知道子状态的结果，此时递归语句不在最后），则是指是否到达初始状态。</p><p>为了判断是否到了收敛条件，要<strong>在函数接口里用一个参数记录当前的位置（或距离目标还有多远）。</strong>如果是求一个解，直接返回这个解；如果是求所有解，要在这里收集解，即把第一步中表示路径的数组path[]复制到解集合里。</p><h3 id="代码模板-1"><a href="#代码模板-1" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dfs模板.</span></span><br><span class="line"><span class="comment"> * @param[in] input 输入数据指针</span></span><br><span class="line"><span class="comment"> * @param[out] path 当前路径，也是中间结果</span></span><br><span class="line"><span class="comment"> * @param[out] result 存放最终结果</span></span><br><span class="line"><span class="comment"> * @param[inout] cur or gap 标记当前位置或距离目标的距离</span></span><br><span class="line"><span class="comment"> * @return 路径长度，如果是求路径本身，则不需要返回长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(type &amp;input, type &amp;path, type &amp;result, <span class="keyword">int</span> cur <span class="keyword">or</span> gap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (数据非法) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (cur == input.size()) &#123; <span class="comment">// 收敛条件</span></span><br><span class="line">    <span class="comment">// if (gap == 0) &#123;</span></span><br><span class="line">        将path放入result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (可以剪枝) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(...) &#123; <span class="comment">// 执行所有可能的扩展动作</span></span><br><span class="line">        执行动作，修改path</span><br><span class="line">        dfs(input, step + <span class="number">1</span> <span class="keyword">or</span> gap--, result);</span><br><span class="line">        恢复path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><strong>累加数</strong></p><p>累加数是一个字符串，组成它的数字可以形成累加序列。</p><p>一个有效的累加序列必须至少包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。</p><p>给定一个只包含数字 ‘0’-‘9’ 的字符串，编写一个算法来判断给定输入是否是累加数。</p><p>说明: 累加序列里的数不会以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况</p><p>输入: “112358”<br>输出: true<br>解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</p><p>输入: “199100199”<br>输出: true<br>解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAdditiveNumber</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = num.size();</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n - i; ++j) &#123;</span><br><span class="line"><span class="built_in">string</span> str1 = num.substr(<span class="number">0</span>, i);</span><br><span class="line"><span class="built_in">string</span> str2 = num.substr(i, j);</span><br><span class="line"><span class="keyword">if</span> ((str1.size() &gt; <span class="number">1</span> &amp;&amp; str1[<span class="number">0</span>] == <span class="string">'0'</span>) || (str2.size() &gt; <span class="number">1</span> &amp;&amp; str2[<span class="number">0</span>] == <span class="string">'0'</span>))<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num1 = atoll(str1.c_str());<span class="comment">//substr(开始位置，长度)</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num2 = atoll(str2.c_str());</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num3 = num1 + num2;</span><br><span class="line"><span class="built_in">string</span> num3_str = to_string(num3);</span><br><span class="line"><span class="built_in">string</span> newstring = str1 + str2 + num3_str;</span><br><span class="line"><span class="keyword">while</span> (newstring.size() &lt; n) &#123;</span><br><span class="line">num1 = num2;</span><br><span class="line">num2 = num3;</span><br><span class="line">num3 = num1 + num2;</span><br><span class="line">newstring += to_string(num3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newstring == num)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p><strong>回溯法 = 深搜 + 剪枝。</strong>一般大家用深搜时，或多或少会剪枝，因此深搜与回溯法没有什么不同，可以在它们之间画上一个等号。</p><p><strong>深搜一般用递归(recursion)来实现.</strong></p></the></excerpt>]]></content>
    
    <summary type="html">
    
      &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;

&lt;p&gt;当题目看不出任何规律，既不能用分治，贪心，也不能用动规时，这时候万能方法——搜索， 就派上用场了。搜索分为广搜BFS和深搜DFS。解决&lt;strong&gt;多阶段最优化问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;广搜里面又有普通广搜，双向广搜，A*搜索等。 &lt;/p&gt;
&lt;p&gt;深搜里面又有普通深搜，回溯法等。&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://itsma.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://itsma.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/dp.html"/>
    <id>https://itsma.github.io/[object Object]/dp.html</id>
    <published>2018-08-22T08:57:22.000Z</published>
    <updated>2018-08-27T02:42:04.754Z</updated>
    
    <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""><p>分治法是将问题分解为两个互不相交的子问题。如二叉树的左右子树遍历等；</p><p>动态规划应用于子问题存在重叠的情况，如最大子数组和，最长公共子序列等；动态规划就是在递归中记录了子问题的解，逐步重构最优解。</p><p>动态规划一般由两种方法来实现，一种为自顶向下的备忘录方式，用递归实现，一种为自底向上的方式，用迭代实现。<br><a id="more"></a></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><ol><li>把问题转化为规模缩小了的同类问题的子问题 </li><li>有明确的不需要继续进行递归的条件(base case)</li><li>有当得到了子问题的结果之后的决策过程</li><li>不记录每一个子问题的解</li></ol><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ol><li>从暴力递归中来 </li><li>将每一个子问题的解记录下来，不断重构最优解</li><li>最终得到问题的解</li><li>把暴力递归的过程，抽象成了状态表达 </li></ol><p>本质上状态空间的状态转移。</p><p>所谓状态转移是指每个阶段的最优状态（对应于子问题的解）可以从之前的某一个或几个阶段的状态中得到，即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解，这个性质叫做<strong>最优子结构</strong>。而不管之前这个状态是如何得到的，这被称之为<strong>无后效性</strong>。</p><p><strong>关键在于：</strong>如何求解递推式！</p><ol><li>如何设置状态</li><li>如何递推，从上一个状态如何转化到下一个状态</li><li>最终达到最优解</li></ol><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><strong><em>题目：</em></strong></p><p>有N件物品和一个空间为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p><p>例如：有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，每件物品数量只有一个，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和。</p><p><strong><em>特点：</em></strong>每种物品仅有一件，可以选择放或不放</p><p><strong><em>分析：</em></strong></p><p><del>只放一件物品价值最大</del>，<del>选取在承重范围内的最大值放进背包</del></p><p><del>只放两件物品价值最大</del>，<del>两种情况</del>：１，<del>在放一件物品最大后</del>，<del>在剩余承重下再放一件</del>；２，<del>重新选择两件物品</del>。这两种情况谁价值大选谁。</p><p><strong><em>自顶向下分析：</em></strong></p><p><strong>两个变量：物品数i和空间j，</strong></p><p><strong>一个所求：背包最大价值。</strong></p><p><strong>数组$W[i][j]$表示有i个物品可以选择放入空间为j的背包中的最大价值，注意是选择放入不是全部放入背包</strong></p><p><strong>当ｉ＝Ｎ且ｊ＝Ｖ时就是所求。</strong></p><p>所以，$W[i][j]$可以由子问题$W[i-1][j]$，即有ｉ－１个物品可选择放入空间为ｊ的背包中的最大价值，加上第ｉ个物品构成。有两种情况：</p><p>第一：第ｉ个物品放入背包，$W[i][j]=W[i-1][j-c_i]+w_i$</p><p>第二：第ｉ个物品不放入背包，$W[i][j]=W[i-1][j]$</p><p>取两者最大值就是i个物品可以选择放入空间为j的背包中的最大价值$W[i][j]$</p><p><strong><em>自底向上求解：</em></strong></p><p>由ｉ＝０，ｊ＝０开始逐步求解$W[i][j]$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> *value,<span class="keyword">int</span> *cost,<span class="keyword">int</span> n,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; W(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v,<span class="number">0</span>)); <span class="comment">//n行v列二维数组，初始化为０</span></span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123; <span class="comment">//第ｉ个物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;v;++j)&#123; <span class="comment">//空间</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j&gt;=cost[i])W[i][j]=value[j];<span class="comment">//初始化第一排数据，即只有一个物品时</span></span><br><span class="line">            <span class="keyword">if</span>(j&lt;cost[i])&#123;  <span class="comment">//书包空间装不下第ｉ个物品时</span></span><br><span class="line">                W[i][j]=W[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                W[i][j]=max(W[i<span class="number">-1</span>][j],W[i<span class="number">-1</span>][j-cost[i]]+value[i]);        </span><br><span class="line">            &#125;          </span><br><span class="line">            max=(W[i][j]&gt;max)W[i][j]:max;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>时间复杂度：</em></strong>$O(NV)$</p><p><strong><em>空间复杂度：</em></strong>$O(NV)$</p><p><strong><em>空间优化：</em></strong>只需要一个一维数组就可以保存需要的数据。空间复杂度可以优化到<em>$O(V)$</em></p><p>上面的方法是用一个二维数组保存子问题的解（ｉ－１个物品放入空间为ｊ的背包的最大价值）</p><p>在做递推的时候只用了ｉ－１行的数据，所以可以使用一个一位数组只保存ｉ－１行的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cost,<span class="keyword">int</span> n,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; W(v+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123; <span class="comment">//n个物品，依次增加种类</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v;j&gt;=<span class="number">1</span>;--j)&#123;　<span class="comment">//逆序，</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=cost[i])&#123;<span class="comment">//空间够放第ｉ个物品时，才放入</span></span><br><span class="line">                W[j]=max(W[j-cost[i]]+value[i],W[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> W[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间ｖ的遍历一定是<strong>逆序</strong>。这样才能保证$W[j-cost[i]]$不会在ｊ的一次循环内被更新，保证了物品只能使用一次。比如，</p><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><strong><em>题目：</em></strong></p><p>有N种物品和一个空间为V的背包，<strong>每种物品都有无限件可用</strong>。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包空间，且价值总和最大。</p><p><strong><em>分析：</em></strong></p><p>N种物品无限使用，也就相当于少了一个限制，求空间为Ｖ的背包最大价值是多少。</p><p>$W[V]$表示空间为Ｖ的书包的最大价值。</p><p>$W(V)=argmax(W(V-c_i)+w_i)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapack_comlete</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cost,<span class="keyword">int</span> n,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; W(v+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=v;++i)&#123; <span class="comment">//空间为ｉ时的最大价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;　<span class="comment">//逐个物品进行尝试，这保证可以使用无限多次</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;cost[j])<span class="keyword">continue</span>;</span><br><span class="line">            W[i]=max(W[i-cost[j]]+value[j],W[i<span class="number">-1</span>]);     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> W[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p><strong><em>题目：</em></strong></p><p>有N种物品和一个空间为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包空间，且价值总和最大。</p><p><strong><em>分析：</em></strong></p><p>对于第ｉ个物品，<br>$$<br>W[i][j]=max(W[i-1][j],W[i-1][j-k<em>c_i]+k</em>c_i)<br>$$<br>其中，$k$的取值范围是$(1,n[i])$．</p><p>时间复杂度是$O(V*\sum(n[i]))$</p><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p><strong><em>题目：</em></strong></p><p>给出两个字符串，求出这样的一个最长的公共子序列的<strong>长度</strong>：子序列中的每个字符都能在两个原串中找到，而且每个字符的先后顺序和原串中的先后顺序一致。</p><p><strong><em>分析：</em></strong></p><p>公共子序列 ： 如果序列C既是序列A的子序列，同时也是序列B的子序列，则称它为序列A和序列B的公共子序列。<strong>空序列是任何两个序列的公共子序列。</strong></p><ol><li>确定动态规划问题，</li><li>寻找ＤＰ数组，一维ｏｒ二维。题目包含两个变量，字符串１和字符串２。</li><li>确定递推式。关于字符串的变量一般就是长度。两个字符串的长度变化对最长子序列的结果都有影响。确定$DP[i][j]$表示字符串１中长度为ｉ时与字符串２中长度为ｊ的最长公共子序列的<strong>长度</strong>。</li><li>$DP[i][j]$可以由三部分（$DP[i-1][j]，DP[i][j-1]，DP[i-1][j-1]$）递推得到，所以，有</li></ol><p>$$<br>DP[i][j]=max(DP[i-1][j],DP[i][j-1]),if(str1[i]!=str2[j])<br>$$</p><p>$$<br>DP[i][j]=DP[i-1][j-1]+1,if(str1[i]=str2[j])<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCommonSeq</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1=str1.size();</span><br><span class="line">    <span class="keyword">int</span> len2=str2.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; DP(len1+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len2+<span class="number">1</span>,<span class="number">0</span>));<span class="comment">//+1是为了更好的处理单个字符的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len2;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                DP[i][j]=DP[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DP[i][j]=max(DP[i<span class="number">-1</span>][j],DP[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DP[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></the></excerpt>]]></content>
    
    <summary type="html">
    
      &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;

&lt;p&gt;分治法是将问题分解为两个互不相交的子问题。如二叉树的左右子树遍历等；&lt;/p&gt;
&lt;p&gt;动态规划应用于子问题存在重叠的情况，如最大子数组和，最长公共子序列等；动态规划就是在递归中记录了子问题的解，逐步重构最优解。&lt;/p&gt;
&lt;p&gt;动态规划一般由两种方法来实现，一种为自顶向下的备忘录方式，用递归实现，一种为自底向上的方式，用迭代实现。&lt;br&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://itsma.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://itsma.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>分治</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/divideconquer.html"/>
    <id>https://itsma.github.io/[object Object]/divideconquer.html</id>
    <published>2018-08-20T02:08:50.000Z</published>
    <updated>2018-08-22T08:51:11.964Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>分治法，递归求解一个问题，在每一层递归中应用<strong>分解，解决和合并</strong>三个步骤。<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="分解"><a href="#分解" class="headerlink" title="分解"></a>分解</h2><p>将问题划分为子问题，子问题的形式与原问题一样，只是规模更小。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>如果子问题的规模足够小，则停止递归，直接求解</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>将子问题的解组合成原问题的解</p><p>有时除了与原问题形式完全一样的规模更小的子问题外，还需要求解与原问题不完全一样的子问题，这些可以在合并步骤完成，</p><h2 id="最大子数组"><a href="#最大子数组" class="headerlink" title="最大子数组"></a>最大子数组</h2><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><h3 id="前序（根左右）"><a href="#前序（根左右）" class="headerlink" title="前序（根左右）"></a>前序（根左右）</h3><p>####　非递归</p><p>栈保存的是访问树节点的顺序，先进后出。入栈表示先不访问节点，出栈表示访问该节点。将当前指针指向的节点又看做根节点。</p><p>先序遍历二叉树的时候，首先访问根结点，再访问左孩子，最后访问右孩子。</p><p>在二叉树先序遍历非递归算法中:</p><ol><li>先将根结点压栈，在栈不为空的时候执行循环;</li><li>让栈顶元素p出栈，访问栈顶元素p;</li><li>如果p的右孩子不为空，则让其右孩子先进栈</li><li>如果p的左孩子不为空，则再让其左孩子进栈</li></ol><p><strong>(注意：进栈顺序一定是先右孩子，再左孩子)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode *p=t;</span><br><span class="line">    stk.push(p);</span><br><span class="line">    <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">        p=stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">" "</span>;<span class="comment">//访问根节点</span></span><br><span class="line">        <span class="comment">//注意入栈顺序</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)stk.push(p-&gt;right);<span class="comment">//右子节点先入栈</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left)stk.push(p-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode *p=t;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>||!stk.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">" "</span>;<span class="comment">//先访问根节点</span></span><br><span class="line">            stk.push(p);</span><br><span class="line">            p=p-&gt;left;  <span class="comment">//再访问左子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stk.empty())&#123;</span><br><span class="line">            p=stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            p=p-&gt;right; <span class="comment">//右节点进行同样的操作，可以为空节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序（左根右）"><a href="#中序（左根右）" class="headerlink" title="中序（左根右）"></a>中序（左根右）</h3><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><p>栈保存的是访问树节点的顺序，先进后出。入栈表示先不访问节点，出栈表示访问该节点。将当前指针指向的节点又看做根节点。</p><p>中序遍历的顺序是从最左节点开始的，所以需要将根节点的左节点全部入栈，直到最左节点(即左子节点为空)也入栈，将最左节点出栈进行访问，然后将当前的指针P指向栈顶结点的右孩子，使其作为根节点继续相同的处理。</p><ol><li>刚开始指针指向树的根节点。将节点入栈后将指针指向左子节点，表示的是优先访问左子节点，先不访问根节点。</li><li>继续入栈根节点，直到左子节点为空，就表示没有左子树了。</li><li>将栈顶元素出栈，表示访问该节点，即左子节点为空的根节点。</li><li>按照中序遍历规则，输出该节点。</li><li>将指针指向该节点的右子节点，表示访问右子树。继续遍历。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder_NoRecur</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode *p=t;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>||!stk.empty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;<span class="comment">//将节点的左子树全部遍历</span></span><br><span class="line">            stk.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stk.empty())&#123;</span><br><span class="line">            p=stk.top();  <span class="comment">//添加空栈判断加强鲁邦性if(!stk.empty())&#123;&#125;</span></span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            p=p-&gt;right;　<span class="comment">//转换到右节点，可以为空节点          </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/SHERO-Vae/p/5800363.html" target="_blank" rel="noopener">参考</a></p><h3 id="后序（左右根）"><a href="#后序（左右根）" class="headerlink" title="后序（左右根）"></a>后序（左右根）</h3><h4 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h4><p>后序遍历的非递归实现是三种遍历方式中最难的一种。</p><p>后序遍历也是最左节点开始遍历，所以需要从根结点开始，将所有<strong>最左结点</strong>全部压栈，每当一个结点出栈时，都先扫描该结点的右子树，只有当一个结点的左孩子和右孩子结点均被访问过了，才能访问结点自身。</p><p>辅助变量：</p><ul><li>ｆｌａｇ＝１表示当前结点的左孩子为空或者已被访问</li><li>ＴｒｅｅＮｏｄｅ　*ｐｒｅ：表示之前访问的节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode *p=t;  <span class="comment">//当前指针指向的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;　<span class="comment">//标识位，用来表示左子节点已经被访问　或者　左子节点为空</span></span><br><span class="line">    TreeNode *pre;  <span class="comment">//前驱节点，表示访问过的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;　<span class="comment">//所有最左节点入栈，从最左节点开始</span></span><br><span class="line">            stk.push(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        pre=<span class="literal">nullptr</span>;　<span class="comment">//指向当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">while</span>(!stk.empty() &amp;&amp; flag==<span class="number">1</span>)&#123;　<span class="comment">//当左子树已经被访问或者为空时，存在两种情况：</span></span><br><span class="line">            p=stk.top(); <span class="comment">//只获取栈顶元素，不出栈访问。因为还存在两种情况：</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right==pre)&#123; <span class="comment">//１：节点的右子节点为空　或者　右子节点已经被访问过</span></span><br><span class="line">                stk.pop();　<span class="comment">//出栈访问该节点</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;p-&gt;val&lt;&lt;<span class="string">" "</span>;　</span><br><span class="line">                pre=p;　　<span class="comment">//表示该节点访问过了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//２：右子节点不为空，则先处理右子节点</span></span><br><span class="line">                p=p-&gt;right;</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(!stk.empty()); <span class="comment">//有分号，使用dowhile是因为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法具有一个<strong>特性</strong>：就是当访问某个结点时，栈中所保存的元素正好是这个结点的所有祖先。</p><p>那么知道了这个特性，我们就很容易解决下面如下问题：</p><p>(1).当给定一个叶子结点，要求输出该叶子结点的所有祖先</p><p>(2).输出根结点到所有叶子结点的路径</p><p>(3).如果二叉树结点的值是数值，那么求每条路径上值之和，也可以利用二叉树后序遍历的非递归算法这个特性</p><p><a href="https://www.cnblogs.com/greedyco/p/7187408.html" target="_blank" rel="noopener">参考</a></p><h2 id="二叉树深度"><a href="#二叉树深度" class="headerlink" title="二叉树深度"></a>二叉树深度</h2><p>问题：给定一个二叉树，求它的深度。</p><p><strong>分解：</strong>树的深度可以分解为（左子树深度＋１）（右子树深度＋１）取其中的最大值。</p><p><strong>解决：</strong>递归条件是空树返回０。</p><p><strong>合并：</strong>可以采用参数返回，也可以采用ｖｏｉｄ。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DepthOfTree</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left_depth=DepthOfTree(t-&gt;left)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right_depth=DepthOfTree(t-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> max(left_depth,right_depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断平衡树（AVL）"><a href="#判断平衡树（AVL）" class="headerlink" title="判断平衡树（ＡＶＬ）"></a>判断平衡树（ＡＶＬ）</h2><p>平衡二叉树(AVL)：</p><p>它或者是一颗空树；</p><p>或者具有以下性质的二叉树：</p><ol><li>每个节点的左子树和右子树的深度之差(平衡因子)的绝对值不超过1。</li><li>它的左子树和右子树都是一颗平衡二叉树。</li></ol><p><strong>分解：</strong>根节点判断，左子节点判断，右子节点判断。这三种情况是问题一样但规模不同</p><p><strong>解决：</strong>空树返回真，利用求二叉树深度函数进行判断</p><p><strong>合并：</strong>根据ＡＶＬ树的定义，只有在左右子树深度不超过１ ＆＆ 左子树符合要求 ＆＆ 右子树也符合要求，才能返回真。</p><p><strong>最直接的求法：</strong>遍历二叉树，求每一个节点的左右子树深度做判断。时间复杂度是$O(N^2)$，太费时间。</p><p>（1）如果二叉树为空，返回真 </p><p>（2）如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsAVL</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//空树返回真</span></span><br><span class="line">    <span class="keyword">int</span> ld=DepthOfTree(t-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> rd=DepthOfTree(t-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(ld-rd&gt;=<span class="number">-1</span> &amp;&amp; ld-rd&lt;=<span class="number">1</span> &amp;&amp; IsAVL(t-&gt;left) &amp;&amp; IsAVL(t-&gt;right))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>$O(N)$求法</strong>：遍历二叉树是不可避免的，所以应该在求深度的地方优化。采用后序遍历的方式（左右根），在左右子节点的时候顺便求深度即可优化算法，也就是自底向上遍历。</p><p><strong>关键在于如何在遍历左右子节点时求深度：</strong>递归的时候需要保存左右子树的深度信息，<del>需要额外的两个变量</del>。在合并的时候只需要一个变量来保存深度就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsAVL</span><span class="params">(TreeNode *t,<span class="keyword">int</span> &amp;deep)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        deep=<span class="number">0</span>;　<span class="comment">//deep用于保存处理节点的深度。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    bool left=IsAVL(t-&gt;left,deep);//先访问处理左子树</span></span><br><span class="line"><span class="comment">    int ld=deep; //处理完左子树后的深度，也就是左子树的深度</span></span><br><span class="line"><span class="comment">    bool right=IsAVL(t-&gt;right,deep);//再访问处理右子树</span></span><br><span class="line"><span class="comment">    int rd=deep;　//右子树的深度</span></span><br><span class="line"><span class="comment">    //处理根节点：左子树是AVL ＆＆ 右子树也是AVL ＆＆ 根节点的左右深度不超过１</span></span><br><span class="line"><span class="comment">    if(left &amp;&amp; right &amp;&amp; ld-rd&gt;=-1 &amp;&amp; ld-rd&lt;=1)&#123;</span></span><br><span class="line"><span class="comment">        deep=(ld&gt;rd)?ld+1:rd+1;  //返回上层时深度是左右子树深度的最大值要加１</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return false;   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> ld,rd;</span><br><span class="line">    <span class="comment">//左右子树做了递归，不用再考虑，只需考虑根节点处理</span></span><br><span class="line">    <span class="keyword">if</span>(IsAVL(tree-&gt;left,ld)&amp;&amp;IsAVL(tree-&gt;right,rd)&amp;&amp;ld-rd&gt;=<span class="number">-1</span>&amp;&amp;ld-rd&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        deep=(ld&gt;rd)?ld+<span class="number">1</span>:rd+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BST转双向链表"><a href="#BST转双向链表" class="headerlink" title="BST转双向链表"></a>BST转双向链表</h2><p>BST(Binary Sort Tree)，二叉排序树，又名二叉查找树，又名二叉搜索树</p><p>它或者是一棵空树；</p><p>或者是具有下列性质的<a href="http://baike.baidu.com/view/88806.htm" target="_blank" rel="noopener">二叉树</a>： </p><ol><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值； </li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li></ol><p><strong>题目：</strong>输入一棵二叉搜索树，将其转换为一个排序的双向链表。要求：不能创建任何新的结点，只能调整树中结点指针的指向。</p><p>分析：</p><ol><li>输入：二叉树根节点指针ＴｒｅｅＮｏｄｅ　*ｒｏｏｔ</li><li>输出：双向链表，应该指明头节点，即返回一个指针指向双向链表的第一个元素，需要一个指针变量ｈｅａｄ指向头节点，该指针不能随着函数变化，所以应该设置全局指针。</li><li>递归截止：返回ｎｕｌｌｐｔｒ</li><li>将左右子节点链接起来需要知道前一个节点信息，所以需要一个变量ｐｒｅ保存前一个节点。要保证每次调用ｐｒｅ的指向不变。可以使用<strong>指针的指针</strong>或者<strong>全局变量</strong></li><li>ｐｒｅ指向前一个节点，ｃｕｒ指向当前处理的根节点，进行连接即可。</li><li>右子树进行同样的操作。也就是递归处理右子树（当前根节点变成了右子节点）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *head=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BSTtoList</span><span class="params">(TreeNode *t)</span></span>&#123;</span><br><span class="line">    TreeNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">    transform(t,&amp;pre);<span class="comment">//取pre指针的地址，指针的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(TreeNode *t,TreeNode **pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    transform(t-&gt;left,pre);<span class="comment">//先处理左子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    TreeNode *cur=t; <span class="comment">//cur指向当前访问的节点(根节点)</span></span><br><span class="line">    <span class="keyword">if</span>(*pre==<span class="literal">nullptr</span>)&#123;<span class="comment">//在最左节点处</span></span><br><span class="line">        *pre=cur;</span><br><span class="line">        head=cur;<span class="comment">//指向第一个指针</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//连接两个节点</span></span><br><span class="line">        cur-&gt;left=*pre;</span><br><span class="line">        (*pre)-&gt;right=cur;</span><br><span class="line">        *pre=cur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    transform(t-&gt;right,pre);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;分治法，递归求解一个问题，在每一层递归中应用&lt;strong&gt;分解，解决和合并&lt;/strong&gt;三个步骤。&lt;br&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://itsma.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://itsma.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>排序总结</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/sort.html"/>
    <id>https://itsma.github.io/[object Object]/sort.html</id>
    <published>2018-08-19T08:09:53.000Z</published>
    <updated>2018-08-19T09:16:48.788Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>从时间复杂度，空间复杂度，稳定性和初始状态等方面分析排序算法<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="../../../../图片/sort.png" alt="排序算法"></the></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>简单排序在已经排好序的情况下时间复杂度是最好的，在逆序的情况下是最坏的。</p><p>快速排序在基准元素是最小或最大值时是最坏的。</p><p>归并排序与堆排序是最稳定的。</p><p>##　空间复杂度</p><p>只有<strong>归并排序和快速排序</strong>需要额外的空间。</p><p>因为采用递归的方法，递归的次数是$O(logN)$。每一次递归都需要空间。</p><p>快速排序在对序列的操作过程中只需花费常数级的空间。空间复杂度$O(1)$。 但需要注意快速排序每次递归都会返回一个基准元素的下标位置，必须使用栈。递归栈上需要花费最少$logN$最多$N$的空间。</p><p>归并排序每次递归需要用到一个辅助表，长度与待排序的表相等，虽然递归次数是$logN$，但每次递归都会释放掉所占的辅助空间，所以下次递归的栈空间和辅助空间与这部分释放的空间就不相关了，因而空间复杂度还是$O(N)$。</p><p>归并排序需要额外的$O(N)$的空间。</p><p>快速排序需要额外的$O(NlogN)$的空间。</p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>稳定排序：插入，冒泡，归并</p><p>不稳定排序：选择，快速，堆</p><p><strong>归并排序：</strong>在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，<strong>归并排序也是稳定的排序算法。</strong></p><p><strong>堆排序：</strong>在叶子节点与父节点这3个元素之间的选择最大或最小不会破坏稳定性。但在叶子节点之上的节点交换会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p><p><strong>快速排序：</strong>在基准元素与有相同元素之间交换时会破坏稳定性。（５，３，９，３，８，１０）中基准元素５与第二个３交换。</p><p><strong>选择排序：</strong>序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p><h2 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h2><p>算法复杂度与数组的初试状态无关：</p><p>一堆（<strong>堆排序</strong>）乌龟（<strong>归并排序</strong>）选（<strong>选择排序</strong>）基（<strong>基数排序</strong>）友</p><p>元素总<strong>比较次数</strong>与初始状态无关的有：<strong>选择排序</strong>、<strong>基数排序</strong>。</p><p>元素总<strong>移动次数</strong>与初始状态无关的有：<strong>归并排序</strong>、<strong>基数排序</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;从时间复杂度，空间复杂度，稳定性和初始状态等方面分析排序算法&lt;br&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://itsma.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://itsma.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/heapsort.html"/>
    <id>https://itsma.github.io/[object Object]/heapsort.html</id>
    <published>2018-08-17T01:56:52.000Z</published>
    <updated>2018-08-17T09:21:51.376Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>堆排序是利用堆的性质来对数组进行排序，主要分为<strong>建堆</strong>和<strong>交换</strong>两个步骤<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆在形式上是一棵满足一定性质的二叉树。</p><p>由于二叉树良好的形态已经包含了父节点和孩子节点的关系信息，因此就可以不需要使用链表而使用<strong>数组</strong>来存储堆。</p><p>堆分为两种，最大堆和最小堆，以最大堆为例，最大堆保持了根结点大于两个左右两个孩子，同时所有子树一次类推。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[]=&#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>设父节点的编号为</strong> <strong>i, 则其左孩子节点的编号为2*i+1, 右孩子节点的编号为2*i+2</strong> </p><p><strong>设孩子节点的编号为i, 则其父节点的编号为(i-1)/2</strong></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序指的就是利用堆的性质对数组进行排序。</p><p><strong>小顶堆中根节点小于两个左右子节点的性质。</strong></p><p>将一个无序数组看做是一个完全二叉树，此时没有成堆。</p><h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><p>将该数组进行建堆操作，</p><p>即将父节点和左右子节点三个数进行比较，最小的数作为父节点，</p><p>循环操作整颗树后，根节点就是数组中最小的树。</p><p>问题转化为将<strong>树中的最小值移动至根节点</strong>。</p><p><img src="http://img.chuansong.me/mmbiz_png/zrIoKPEFItdOmAIKW4mHjIkFD6zKGNLBFSEv8f6duBoE3YAyNzhUuV3woKzCPrYpibQ3icB1zvhrkSZMDKP10V0Q/?wx_fmt=png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr,<span class="keyword">int</span> unsortSize)</span></span>&#123;<span class="comment">//unsortSize表示未排序元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> rootIndex=unsortSize/<span class="number">2</span><span class="number">-1</span>;<span class="comment">//第一个非叶子节点的下标</span></span><br><span class="line">    <span class="keyword">for</span>(;rootIndex&gt;=<span class="number">0</span>;rootIndex--)&#123;</span><br><span class="line">        <span class="comment">//左右节点都存在，比较三个数，最小值与根节点交换</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*rootIndex+<span class="number">2</span>&lt;=unsortSize)&#123;<span class="comment">//注意是小于未排序数列的大小，不是整个数列的大小</span></span><br><span class="line">            <span class="keyword">if</span>(arr[<span class="number">2</span>*rootIndex+<span class="number">1</span>]&lt;arr[<span class="number">2</span>*rootIndex+<span class="number">2</span>])&#123;<span class="comment">//左节点小于右节点</span></span><br><span class="line">                <span class="keyword">if</span>(arr[rootIndex]&gt;arr[<span class="number">2</span>*rootIndex+<span class="number">1</span>])&#123;<span class="comment">//左节点最小</span></span><br><span class="line">                    swap(arr[rootIndex],arr[<span class="number">2</span>*rootIndex+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;　　　<span class="comment">//右节点小于左节点</span></span><br><span class="line">                <span class="keyword">if</span>(arr[rootIndex]&gt;arr[<span class="number">2</span>*rootIndex+<span class="number">2</span>])&#123;<span class="comment">//右节点最小</span></span><br><span class="line">                    swap(arr[rootIndex],arr[<span class="number">2</span>*rootIndex+<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;　<span class="keyword">else</span> &#123;  <span class="comment">//右节点不存在，只比较根节点与左节点</span></span><br><span class="line">            <span class="keyword">if</span>(arr[rootIndex]&gt;arr[<span class="number">2</span>*rootIndex+<span class="number">2</span>])&#123;</span><br><span class="line">                swap(arr[rootIndex],arr[<span class="number">2</span>*rootIndex+<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意建堆时节点数是小于未排序数列的大小，不是整个数列的大小</strong></p><h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><p>建堆操作后，数组中的最小值就是根节点。为了循环遍历，我们将最小值与数组最后一个数进行交换。这样，除数组最后一个数之外又变成了一个<strong>能构成完全二叉树的无序数组</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=arr[end];</span><br><span class="line">    arr[end]=arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>堆排序就是先建立一个小根堆，然后不断地交换堆顶最小元素，交换N-1次就OK了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size=arr.size();</span><br><span class="line">    <span class="keyword">if</span>(size&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size;i&gt;<span class="number">1</span>;--i)&#123;<span class="comment">//size表示未排序元素个数，当只剩一个时就退出，所以是i&gt;1</span></span><br><span class="line">        buildHeap(arr,i);</span><br><span class="line">        swapHeap(arr,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>时间复杂度：</p><ul><li>建堆复杂度为$O(logN)$</li><li>交换可以忽略</li><li>需要进行$N-1$次建堆</li></ul><p>所以，堆排序的时间复杂度是$O(N-1)*O(logN)=O(NlogN)$</p><p><strong>不稳定排序</strong></p><p>在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， … 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法</p><p><a href="http://chuansong.me/n/2129062451005" target="_blank" rel="noopener">参考资料</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;堆排序是利用堆的性质来对数组进行排序，主要分为&lt;strong&gt;建堆&lt;/strong&gt;和&lt;strong&gt;交换&lt;/strong&gt;两个步骤&lt;br&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://itsma.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://itsma.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/mergesort.html"/>
    <id>https://itsma.github.io/[object Object]/mergesort.html</id>
    <published>2018-08-16T09:56:24.000Z</published>
    <updated>2018-08-17T01:49:56.752Z</updated>
    
    <content type="html"><![CDATA[<excerpt in="" index="" |="" 首页摘要=""><p>归并排序的基本思想也是分治法。与快速排序不一样的是，归并排序是先分后治，而快排是先治后分</p><a id="more"></a><p><the rest="" of="" contents="" |="" 余下全文=""><br><img src="../../../../图片/ms.png" alt=""></the></p><p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现。</p><h3 id="分"><a href="#分" class="headerlink" title="分"></a>分</h3><p>在<strong>分</strong>的阶段可以采用递归方法实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=end)<span class="keyword">return</span>;<span class="comment">//递归结束条件</span></span><br><span class="line">    <span class="comment">//分</span></span><br><span class="line">    <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;<span class="comment">//将数组从中间分开</span></span><br><span class="line">    mergeSort(arr,start,mid);</span><br><span class="line">    mergeSort(arr,mid+<span class="number">1</span>,end);</span><br><span class="line">    <span class="comment">//治</span></span><br><span class="line">    merge(arr,start,mid,end,temp);<span class="comment">//合并两个有序数组arr[start,mid]和arr[mid+1,end]到数组temp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="治"><a href="#治" class="headerlink" title="治"></a>治</h3><p>在<strong>治</strong>的阶段将问题转化为了<strong>合并相邻有序子序列</strong>：</p><p>例如，｛８｝和｛４｝｛４，８｝和｛５，７｝｛４，５，７，８｝和｛１，２，３，６｝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> mid,<span class="keyword">int</span> end,<span class="keyword">int</span> *temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=start;　<span class="comment">//左序列指针</span></span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>; <span class="comment">//右序列指针</span></span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>; <span class="comment">//临时数组指针</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=end)&#123;</span><br><span class="line">        temp[k++]=((arr[i]&lt;arr[j])?arr[i++]:arr[j++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        temp[k++]=arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=end)&#123;</span><br><span class="line">        temp[k++]=arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;=end)&#123;　<span class="comment">//小于等于</span></span><br><span class="line">        arr[start++]=arr[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>合并操作merge()的平均复杂度是<strong>$O(N)$</strong></p><p>拆分操作是完全二叉树的深度，时间复杂度是<strong>$O(NlogN)$</strong></p><p>所以，最坏、最好和平均时间复杂度都是<strong>$O(NlogN)$</strong>。</p><h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a><strong>稳定</strong>排序</h3><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>缺点：需要额外的空间。开辟与arr数组一样大小的空间来存储排好的序列。</p><p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">参考</a></p></excerpt>]]></content>
    
    <summary type="html">
    
      &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;

&lt;p&gt;归并排序的基本思想也是分治法。与快速排序不一样的是，归并排序是先分后治，而快排是先治后分&lt;/p&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://itsma.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://itsma.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/quicksort.html"/>
    <id>https://itsma.github.io/[object Object]/quicksort.html</id>
    <published>2018-08-14T11:43:42.000Z</published>
    <updated>2018-08-17T01:47:58.931Z</updated>
    
    <content type="html"><![CDATA[<p> <excerpt in="" index="" |="" 首页摘要=""><br>快速排序是由冒泡排序演变而来，都属于交换排序。快速排序之所以快速，是因为采用了分治法。<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>快速排序属于交换排序，通过元素之间的比较和交换位置来达到排序目的。不同的是，冒泡排序每一轮只把一个元素冒泡到数组一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数组一边，比它小的移动到数组另一边，从而把数组拆解成两个部分。这种思想就是分治法。</the></p><p>在分治法的思想下，原数列在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。</p><p>这样一共需要多少轮呢？平均情况下需要$logN$轮，因此快速排序算法的平均时间复杂度是 <strong>O(NlogN)</strong></p><h3 id="分"><a href="#分" class="headerlink" title="分"></a>分</h3><p>在分的阶段，就是将基准元素左边序列和右边序列再次治理。可以用递归实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;<span class="comment">//start指向第一个元素，end指向数组最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(start&lt;=end)<span class="keyword">return</span>; <span class="comment">//递归结束条件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//治</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex=partition(arr,start,end); <span class="comment">//进行一次快排，返回分治后基准元素在数组中的位置下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分</span></span><br><span class="line">    qucikSort(arr,start,pivotIndex<span class="number">-1</span>); <span class="comment">//左边递归</span></span><br><span class="line">    quickSort(arr,pivotIndex+<span class="number">1</span>,end);　<span class="comment">//右边递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###　治</p><p>在治的阶段，就是进行一次排序，把数组中大于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。即partition()函数</p><p>partition函数的实现方法有两种：</p><ul><li>挖坑法</li><li>指针交换法</li></ul><h4 id="递归挖坑法"><a href="#递归挖坑法" class="headerlink" title="递归挖坑法"></a>递归挖坑法</h4><p>两个指针start和end分别指向数组的最左和最右两个元素。</p><ol><li>选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴，也是初始的坑位。</li><li>设置两个变量left = 0;right = N - 1;</li><li>从left一直向后走，直到找到一个大于key的值，然后将该数放入坑中，坑位变成了array[left]。</li><li>right一直向前走，直到找到一个小于key的值，然后将该数放入坑中，坑位变成了array[right]。</li><li>重复3和4的步骤，直到left和right相遇，然后将key放入最后一个坑位。</li></ol><p><strong>注意，以第一个元素(start)作为基准元素时，则end先动。否则，以最后的元素(end)作为基准元素，应该(start)先动。start走的时候end是不动的，反之亦然。因为end先走，所有最后一个坑肯定在arr[start]。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//挖坑法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot=arr[start]; <span class="comment">//基准元素</span></span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(strat&lt;end &amp;&amp; arr[end]&gt;=pivot )&#123;　<span class="comment">//大于等于</span></span><br><span class="line">            end--;   <span class="comment">//保持不动</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[start]=arr[end];　<span class="comment">//填“坑”</span></span><br><span class="line">        <span class="comment">//start++;</span></span><br><span class="line">        <span class="keyword">while</span>(start&lt;end &amp;&amp; arr[start]&lt;=pivot )&#123; <span class="comment">//小于等于</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[end]=arr[start];　<span class="comment">//填“坑”</span></span><br><span class="line">        <span class="comment">//end--;</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr[start]=pivot;　<span class="comment">//将基准元素填入最后的“坑”中　此时start&gt;=end</span></span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归指针交换法"><a href="#递归指针交换法" class="headerlink" title="递归指针交换法"></a>递归指针交换法</h4><p>两个指针left和right分别指向数组的最左start和最右end两个元素。</p><ol><li>选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴。</li><li>设置两个变量left = 0;right = N - 1;</li><li>从left一直向后走，直到找到一个大于key的值，right从后至前，直至找到一个小于key的值，然后交换这两个数。</li><li>重复第三步，一直往后找，直到left和right相遇，这时将key放置left的位置即可</li></ol><p><img src="../../../../图片/qs.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot=arr[start];</span><br><span class="line">    <span class="keyword">int</span> left=start; <span class="comment">//左指针</span></span><br><span class="line">    <span class="keyword">int</span> right=end; <span class="comment">//右指针</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right]&gt;pivot )&#123;　<span class="comment">//没有等于号</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[left]&lt;pivot )&#123; <span class="comment">//没有等于号</span></span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[left];</span><br><span class="line">        arr[left]=arr[right];</span><br><span class="line">        a[right]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t=arr[left]; <span class="comment">//指针重合,交换基准元素与指针位置元素</span></span><br><span class="line">    arr[left]=arr[start];</span><br><span class="line">    arr[start]=t</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h3><p>递归的算法主要是在划分子区间，如果要非递归实现快排，只要使用一个栈来保存区间就可以了。  一般将递归程序改成非递归首先想到的就是使用栈，因为递归本身就是一个压栈的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end)<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    stk.push(start);　<span class="comment">//左指针先入栈</span></span><br><span class="line">    stk.push(end);</span><br><span class="line">    <span class="keyword">while</span>(!stk.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> right=stk.top(); <span class="comment">//右指针先出栈</span></span><br><span class="line">        stk.pop();</span><br><span class="line">        <span class="keyword">int</span> left=stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pivotIndex=partition(arr,left,right);</span><br><span class="line">        <span class="keyword">if</span>(pivotIndex<span class="number">-1</span>&gt;left)&#123;　<span class="comment">//注意是left还是start，</span></span><br><span class="line">            stk.push(start);  <span class="comment">//注意入栈顺序，先入左边再入右边,push数组最左端的位置即start</span></span><br><span class="line">            stk.push(pivotIndex<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pivotIndex+<span class="number">1</span>&lt;right)&#123;<span class="comment">//判断的是基准位置与排序区间，应该是partition的left和right</span></span><br><span class="line">            stk.push(pivotIndex+<span class="number">1</span>);</span><br><span class="line">            stk.push(end);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p><strong>不稳定排序</strong></p><p>比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p><p>时间复杂度</p><p>最坏：在基准元素是数组最大或者最小值时，时间复杂度是<strong>$O(N^2)$</strong></p><p>最好：基准元素是中间值。时间复杂度是$O(NlogN)$</p><p>平均：<strong>$O(NlogN)$</strong></p><p><a href="https://blog.csdn.net/qq_36528114/article/details/78667034" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;快速排序是由冒泡排序演变而来，都属于交换排序。快速排序之所以快速，是因为采用了分治法。&lt;br&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://itsma.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://itsma.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>简单排序</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/sortalgorithm.html"/>
    <id>https://itsma.github.io/[object Object]/sortalgorithm.html</id>
    <published>2018-08-13T11:01:51.000Z</published>
    <updated>2018-08-17T01:50:30.504Z</updated>
    
    <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>常用的排序算法分析：选择排序，冒泡排序，插入排序<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>首先遍历数组找到最小（大）元素，存放到数组的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.size();</span><br><span class="line">    <span class="keyword">int</span> min_index; <span class="comment">//需要记录最小值和下标</span></span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">        min_index=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[min_index]&gt;a[j])&#123;</span><br><span class="line">                min_index=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i];</span><br><span class="line">        a[i]=a[min_index];　<span class="comment">//交换</span></span><br><span class="line">        a[min_index]=temp;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>最稳定的排序算法</p><p>最坏，最好和平均时间复杂度总是$O(N^2)$</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h4><p>顺序依次相邻元素比较，大的往后移(从小到大排序)，这样能保证一轮过后最大的数在最后面。再进行一轮比较得到第二大的数，依次类推。</p><p><img src="../../../../图片/bubbleosrt.gif" alt=""></p><p>N个数排序需要重复N-1次；</p><p>第K次排序时，证明已经有K个数排好序，不需要再排。则第K次需要的比较的次数为(N-1-K)次；</p><p>所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=a.size();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)<span class="keyword">return</span>; <span class="comment">//数组为空或者只有一个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123; <span class="comment">//n个数需要　重复　（n-1）次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;++j)&#123;　<span class="comment">//每一次都需要　比较　（n-1-i）次</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])swap(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进</strong>：当数组已经排好序时，可以直接跳出循环得到结果。不需要再做比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=a.size();</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>; <span class="comment">//true表示乱序，</span></span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)<span class="keyword">return</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span> &amp;&amp; flag;i++)&#123; </span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;++j)&#123;　<span class="comment">//如果没有进入if语句说明数组已经排好序，下次直接跳出。</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(a[j],a[j+<span class="number">1</span>]);</span><br><span class="line">                flag=<span class="literal">true</span>; <span class="comment">//有元素交换，则说明排序未完成。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p>时间复杂度</p><ol><li>最好：$O(N)$。在数组已经是正序的情况下，只需要遍历一遍就可以跳出循环。</li><li>最坏：$O(N^2)$。在数组逆序的情况下。</li><li>平均：$O(N^2)$。</li></ol><p><strong>稳定排序</strong></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法原理-2"><a href="#算法原理-2" class="headerlink" title="算法原理"></a>算法原理</h4><p>对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入</p><p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = a.size();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> key=a[i];</span><br><span class="line">        <span class="keyword">while</span>( j&gt;=<span class="number">0</span> &amp;&amp; key&gt;a[j] )&#123;</span><br><span class="line">            a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>]=key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h4><p>时间复杂度：</p><ol><li>最好：$O(N)$。已经排好序的数组。遍历一遍。</li><li>最坏：$O(N^2)$。逆序</li><li>平均：$O(N^2)$。</li></ol><p><strong>不稳定排序：</strong></p><p>序列5 8 5 2 9，第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">参考</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;常用的排序算法分析：选择排序，冒泡排序，插入排序&lt;br&gt;
    
    </summary>
    
      <category term="算法学习" scheme="https://itsma.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://itsma.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Google浏览器插件</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/webtools.html"/>
    <id>https://itsma.github.io/[object Object]/webtools.html</id>
    <published>2018-08-02T02:46:13.000Z</published>
    <updated>2018-08-02T02:54:54.357Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Google浏览器插件：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>适合自己的才是最好的。个人常用插件集合<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p>书签管理</p><h2 id="新标签页"><a href="#新标签页" class="headerlink" title="新标签页"></a>新标签页</h2><p>Infinity新标签页</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>Surfingkeys</p><h2 id="网络代理"><a href="#网络代理" class="headerlink" title="网络代理"></a>网络代理</h2><p>Proxy SwitchyOmega</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>YAAW for Chrome</p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>有道词典Chrome划词插件</p><h2 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h2><p>购物党全网比价工具</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Google浏览器插件：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;适合自己的才是最好的。个人常用插件集合&lt;br&gt;
    
    </summary>
    
      <category term="开发工具" scheme="https://itsma.github.io/categories/DevTools/"/>
    
    
      <category term="Devtools" scheme="https://itsma.github.io/tags/Devtools/"/>
    
  </entry>
  
  <entry>
    <title>Google编程规范</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/googleGuide.html"/>
    <id>https://itsma.github.io/[object Object]/googleGuide.html</id>
    <published>2018-08-01T09:12:11.000Z</published>
    <updated>2018-08-01T09:15:00.119Z</updated>
    
    <content type="html"><![CDATA[<p><strong> Google编程规范：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>Google的C++开源项目编程规范<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="C-编程规范"><a href="#C-编程规范" class="headerlink" title="C++编程规范"></a>C++编程规范</h2><h3 id="1，头文件"><a href="#1，头文件" class="headerlink" title="1，头文件"></a>1，头文件</h3><h4 id="1-1-头文件可以自给自足，可以作为第一个引入的头文件"><a href="#1-1-头文件可以自给自足，可以作为第一个引入的头文件" class="headerlink" title="1.1 头文件可以自给自足，可以作为第一个引入的头文件"></a>1.1 头文件可以自给自足，可以作为第一个引入的头文件</h4><h4 id="1-2-define保护"><a href="#1-2-define保护" class="headerlink" title="1.2 define保护"></a>1.2 define保护</h4><p>项目 <code>foo</code> 中的头文件 <code>foo/src/bar/hd.h</code> 可按如下方式保护:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOO_BAR_HD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_BAR_HD_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//FOO_BAR_HD_H_</span></span></span><br></pre></td></tr></table></figure><h4 id="1-3-尽量避免使用前置声明。使用-include-包含需要的头文件即可。"><a href="#1-3-尽量避免使用前置声明。使用-include-包含需要的头文件即可。" class="headerlink" title="1.3 尽量避免使用前置声明。使用 #include 包含需要的头文件即可。"></a>1.3 尽量避免使用前置声明。使用 <code>#include</code> 包含需要的头文件即可。</h4><p>前置声明就是我在声明一个类（CHouse）的时候，用到了另外一个类的定义（CBed），但是CBed还没有定义呢，而且我还先不需要CBed的定义，只要知道CBed是一个类就够了。那好，我就先声明类CBed，告诉编译器CBed是一个类（不用包含CBed的头文件，然后在CHouse中用到CBed的，都用CBed的指针类型代（因为指针类型固定大小的，但是CBed的大小只用知道了CBed定义才能确定）。等到要实现CHouse定义的时候，就必须要知道CBed的定义了，那是再包好CBed的头文件就行了。</p><ul><li>尽量避免前置声明那些定义在其他项目中的实体.</li><li>函数：总是使用 <code>#include</code>.</li><li>类模板：优先使用 <code>#include</code>.</li></ul><h4 id="1-4-只有当函数少于10行时才将其定义为内联函数"><a href="#1-4-只有当函数少于10行时才将其定义为内联函数" class="headerlink" title="1.4 只有当函数少于10行时才将其定义为内联函数."></a>1.4 只有当函数少于10行时才将其定义为内联函数.</h4><p>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</p><p>不内联的情况：</p><ul><li>循环或switch语句</li><li>析构函数，虚函数，递归函数</li></ul><p>内联函数必须放在 <code>.h</code> 文件中. 如果内联函数比较短, 就直接放在 <code>.h</code> 中.</p><h4 id="1-5-include的路径和顺序"><a href="#1-5-include的路径和顺序" class="headerlink" title="1.5 #include的路径和顺序"></a>1.5 #include的路径和顺序</h4><p><code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能, <code>foo.cc</code> 中包含头文件的次序如下:</p><ol><li>cpp直接的头文件(dir2/foo2.h)</li><li>C库</li><li>C++库</li><li>其他库的头文件</li><li>项目内的头文件</li></ol><p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code> 遗漏某些必要的库时， <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p><p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意</p><p>您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，哪怕您所包含的 <code>foo.h</code> 已经包含了 <code>bar.h</code>, 也照样得包含 <code>bar.h</code>, 除非 <code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的 symbol. </p><h3 id="2，作用域"><a href="#2，作用域" class="headerlink" title="2，作用域"></a>2，作用域</h3><h4 id="2-1-命名空间"><a href="#2-1-命名空间" class="headerlink" title="2.1 命名空间"></a>2.1 命名空间</h4><p>禁止使用using</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cc 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义都置于命名空间中</span></span><br><span class="line"><span class="keyword">void</span> MyClass::Foo() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure><h4 id="2-2-匿名命名空间"><a href="#2-2-匿名命名空间" class="headerlink" title="2.2 匿名命名空间"></a>2.2 匿名命名空间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;  <span class="comment">// 匿名命名空间，编译器自动生成唯一名字</span></span><br></pre></td></tr></table></figure><p>推荐、鼓励在 <code>.cc</code> 中对于不需要在其他地方引用的标识符使用<strong>内部链接性声明</strong> （匿名命名空间和static），但是不要在 <code>.h</code> 中使用。</p><p>所有置于匿名命名空间的声明都具有内部链接性，名称的作用域被限制在当前文件中，无法通过在另外的文件中使用extern声明来进行链接</p><p>函数和变量可以经由声明为 <code>static</code> 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</p><h4 id="2-3-静态成员函数与命名空间非成员函数"><a href="#2-3-静态成员函数与命名空间非成员函数" class="headerlink" title="2.3 静态成员函数与命名空间非成员函数"></a>2.3 静态成员函数与命名空间非成员函数</h4><p><strong>尽量不要使用全局函数，非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内，不要使用静态成员方法，类的静态方法应当和类的实例或静态数据紧密相关.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;  <span class="comment">//非成员函数应置于命名空间中</span></span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><h4 id="2-4-将函数变量尽可能置于最小作用域内-并在变量声明时进行初始化-离第一次使用越近越好"><a href="#2-4-将函数变量尽可能置于最小作用域内-并在变量声明时进行初始化-离第一次使用越近越好" class="headerlink" title="2.4 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化,离第一次使用越近越好"></a>2.4 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化,离第一次使用越近越好</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Not Like This</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = f(); <span class="comment">// 坏——初始化和声明分离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Better Like This</span></span><br><span class="line"><span class="keyword">int</span> j = g(); <span class="comment">// 好——初始化时声明</span></span><br></pre></td></tr></table></figure><p>if, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">'/'</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>有一个例外, 如果<strong>变量是一个对象</strong>, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低，这时应该在循环作用域外面声明这类变量:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低效的实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    Foo f;                  <span class="comment">// 构造函数和析构函数分别调用 1000000 次!</span></span><br><span class="line">    f.DoSomething(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo f;                      <span class="comment">// 构造函数和析构函数只调用 1 次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">    f.DoSomething(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-静态和全局变量"><a href="#2-5-静态和全局变量" class="headerlink" title="2.5 静态和全局变量"></a>2.5 静态和全局变量</h4><p>尽量不用全局函数和全局变量,</p><p>多线程中的全局变量 (含静态成员变量) 不要使用 <code>class</code> 类型 (含 STL 容器), 因为构造和析构顺序的不确定导致不明确行为导致的 bug.</p><p>静态生存周期的对象，即包括了<strong>全局变量，静态变量，静态类成员变量和函数静态变量</strong>，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。即<strong>完全禁用类类型的全局变量</strong>，比如vector(使用 C 数组替代) 和string(使用 <code>const char []</code>)。我们也<strong>不允许用函数返回值来初始化 POD 变量</strong>，除非该函数不涉及任何全局变量。</p><h3 id="3，类"><a href="#3，类" class="headerlink" title="3，类"></a>3，类</h3><h4 id="3-1-不要在构造函数中调用虚函数"><a href="#3-1-不要在构造函数中调用虚函数" class="headerlink" title="3.1 不要在构造函数中调用虚函数"></a>3.1 不要在构造函数中调用虚函数</h4><p>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</p><h4 id="3-2-对于单参数构造函数-请使用explicit关键字来禁止隐式转换"><a href="#3-2-对于单参数构造函数-请使用explicit关键字来禁止隐式转换" class="headerlink" title="3.2 对于单参数构造函数, 请使用explicit关键字来禁止隐式转换"></a>3.2 对于单参数构造函数, 请使用explicit关键字来禁止隐式转换</h4><h4 id="3-3-移动构造函数，移动赋值函数和拷贝构造函数，拷贝赋值函数"><a href="#3-3-移动构造函数，移动赋值函数和拷贝构造函数，拷贝赋值函数" class="headerlink" title="3.3 移动构造函数，移动赋值函数和拷贝构造函数，拷贝赋值函数"></a>3.3 移动构造函数，移动赋值函数和拷贝构造函数，拷贝赋值函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClassName()&#123;&#125;     <span class="comment">//构造函数</span></span><br><span class="line">    ClassName(<span class="keyword">int</span> x)&#123;&#125;  <span class="comment">//有参数的构造函数</span></span><br><span class="line">    ~ClassName()&#123;<span class="keyword">delete</span> *a&#125;  <span class="comment">//析构函数</span></span><br><span class="line">    </span><br><span class="line">    ClassName(<span class="keyword">const</span> ClassName &amp;Obj)&#123;&#125; <span class="comment">//拷贝构造函数</span></span><br><span class="line">    ClaaName&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ClassName &amp;Obj)&#123;  <span class="comment">//拷贝赋值函数</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ClassName(ClassName &amp;&amp;Obj)&#123;&#125;   <span class="comment">//移动构造函数</span></span><br><span class="line">    ClassName&amp; <span class="keyword">operator</span>=(ClassName &amp;Obj)&#123;  <span class="comment">//移动赋值函数</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-3-1-拷贝构造函数"><a href="#3-3-1-拷贝构造函数" class="headerlink" title="3.3.1 拷贝构造函数:"></a>3.3.1 <strong>拷贝构造函数:</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyClass foo;</span><br><span class="line"><span class="function">MyClass <span class="title">bar</span><span class="params">(foo)</span></span>;       <span class="comment">// 对象初始化: 调用拷贝构造函数</span></span><br><span class="line">MyClass baz = foo;      <span class="comment">// 对象初始化: 调用拷贝构造函数</span></span><br><span class="line">foo = bar;              <span class="comment">// 对象已经被初始化，调用拷贝赋值</span></span><br></pre></td></tr></table></figure><p>什么时候用到拷贝构造函数？  </p><ol><li>一个对象以值传递的方式传入函数体；</li><li>一个对象以值传递的方式从函数返回； </li><li>一个对象需要通过另外一个对象进行初始化</li></ol><h5 id="3-3-2-深拷贝"><a href="#3-3-2-深拷贝" class="headerlink" title="3.3.2 深拷贝"></a>3.3.2 <strong>深拷贝</strong></h5><p>如果一个类拥有资源，当这个类的对象发生复制过程的时候，<strong>资源重新分配</strong>，例如需要新开辟内存，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。</p><p>如对象A=B。这时，如果B中有一个成员变量指针已经申请了内存，浅拷贝(默认拷贝构造函数)则是A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</p><h5 id="3-3-3-移动构造函数"><a href="#3-3-3-移动构造函数" class="headerlink" title="3.3.3 移动构造函数"></a>3.3.3 <strong>移动构造函数</strong></h5><p>移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。  这里未命名的对象就是那些临时变量，甚至都不会有名称。</p><p>典型的未命名对象就是<strong>函数的返回值或者类型转换的对象</strong>。  </p><p>使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">fn</span><span class="params">()</span></span>;            <span class="comment">// 函数返回一个 MyClass 对象</span></span><br><span class="line">MyClass foo;             <span class="comment">// 默认构造函数</span></span><br><span class="line">MyClass bar = foo;       <span class="comment">// 拷贝构造函数</span></span><br><span class="line">MyClass baz = fn();      <span class="comment">// 移动构造函数</span></span><br><span class="line">foo = bar;               <span class="comment">// 拷贝赋值</span></span><br><span class="line">baz = MyClass();         <span class="comment">// 移动赋值</span></span><br></pre></td></tr></table></figure><h5 id="3-3-4-区别"><a href="#3-3-4-区别" class="headerlink" title="3.3.4 区别:"></a>3.3.4 <strong>区别:</strong></h5><p>拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。  而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。</p><h5 id="3-3-5-总结"><a href="#3-3-5-总结" class="headerlink" title="3.3.5 总结"></a>3.3.5 总结</h5><p>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.</p><p>如果你的类不需要拷贝 / 移动操作, 请显式地通过在 <code>public</code> 域中使用 <code>= delete</code> 或其他手段禁用之.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable.</span></span><br><span class="line">MyClass(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><h4 id="3-4-仅当只有数据成员时使用struct，其它一概使用class"><a href="#3-4-仅当只有数据成员时使用struct，其它一概使用class" class="headerlink" title="3.4 仅当只有数据成员时使用struct，其它一概使用class"></a>3.4 仅当只有数据成员时使用struct，其它一概使用class</h4><h4 id="3-5-继承"><a href="#3-5-继承" class="headerlink" title="3.5 继承"></a>3.5 继承</h4><p>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承</p><h5 id="3-5-1-组合"><a href="#3-5-1-组合" class="headerlink" title="3.5.1 组合"></a>3.5.1 组合</h5><p>组合类：一个类(Head类)里面的数据成员是另一个类的对象，即内嵌其他类的对象作为自己的成员。</p><p>Eye,Nose,Mouth,Ear这些类都是Head类的一部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Eye&#123;void look()&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nose</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouth</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ear</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Head</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">look</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_eye.look()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Eye m_eye;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果A类是B类的一部分，则不要让B类去继承A类，而是采用组合的形式。如果A类和B类毫无关系，我们不应该为了让B类多一个功能而去让B继承A。如果在逻辑上B是A的一种，即B类的man也是A类的 Hunman的一种我们就可以让B类去继承A类。</p><h5 id="3-5-2-继承"><a href="#3-5-2-继承" class="headerlink" title="3.5.2 继承"></a>3.5.2 继承</h5><p>所有继承必须是 <code>public</code> 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.</p><p>对于可能被子类访问的成员函数, 不要过度使用 <code>protected</code> 关键字.</p><p>数据成员都必须是 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#access-control" target="_blank" rel="noopener">私有的</a>.</p><p>#####　3.5.3 虚函数</p><p>能够根据<strong>指针</strong>所指类型调用对应的类对象，实现函数调用时的多态性。</p><p>虚函数必须声明是指针才有多态，即基类的指针指向了子类的对象，虚函数调用的是子类对象的函数，不是虚函数则调用的是基类对象的函数。</p><p>基类的析构函数应该是虚函数。</p><p>派生类对象构造的时候先调用基类的构造函数再调用派生类的构造函数，析构的时候先调用派生类析构函数再调用基类析构函数。派生类的析构函数会只析构自己的那部分，这时候如果基类的析构函数不是虚函数，则不能调用基类的析构函数析构从基类继承来的那部分成员，所以就会出现只删一半的现象，造成内存泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不管析构函数是否是虚函数(即是否加virtual关键词)，delete时基类和子类都会被释放；</span></span><br><span class="line">SubClass* pObj = <span class="keyword">new</span> SubClass(); <span class="comment">//子类指针指向子类对象</span></span><br><span class="line"><span class="keyword">delete</span> pObj; <span class="comment">//析构时，调用的子类的析构，即子类的析构函数，先析构子类再析构基类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BaseClass* pObj = <span class="keyword">new</span> SubClass(); <span class="comment">//基类指针指向子类对象，</span></span><br><span class="line">pObj-&gt;dosomething();<span class="comment">//如果dosomething()是虚函数,则调用的是子类dosomething()函数;如果dosomething()不是虚函数，则该语句调用的是基类的dosomething()函数</span></span><br><span class="line"><span class="keyword">delete</span> pObj;</span><br><span class="line"><span class="comment">//若析构函数是虚函数(即加上virtual关键词)，delete时基类和子类都会被释放；</span></span><br><span class="line"><span class="comment">//若析构函数不是虚函数(即不加virtual关键词)，delete时只释放基类，不释放子类；</span></span><br></pre></td></tr></table></figure><h4 id="3-6-声明顺序"><a href="#3-6-声明顺序" class="headerlink" title="3.6 声明顺序"></a>3.6 声明顺序</h4><p>类定义一般应以 <code>public:</code> 开始, 后跟 <code>protected:</code>, 最后是 <code>private:</code>. 省略空部分.</p><p>在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: </p><ul><li>类型 (包括 <code>typedef</code>, <code>using</code>和嵌套的结构体与类),</li><li>常量</li><li>工厂函数</li><li>构造函数</li><li>赋值运算符</li><li>析构函数</li><li>其他函数</li><li>数据成员</li></ul><p>不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中</p><h3 id="4，函数"><a href="#4，函数" class="headerlink" title="4，函数"></a>4，函数</h3><h4 id="4-1-参数顺序"><a href="#4-1-参数顺序" class="headerlink" title="4.1 参数顺序"></a>4.1 参数顺序</h4><p>函数的参数顺序为: 输入参数在先, 后跟输出参数.</p><h4 id="4-2-函数长度"><a href="#4-2-函数长度" class="headerlink" title="4.2 函数长度"></a>4.2 函数长度</h4><p>如果函数超过 <strong>40 行</strong>, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p><h4 id="4-3-引用参数"><a href="#4-3-引用参数" class="headerlink" title="4.3 引用参数"></a>4.3 引用参数</h4><p>所有按引用传递的参数必须加上 <code>const</code>。</p><p>输入参数是值参或 <code>const</code> 引用，输入参数可以是 <code>const</code> 指针，但决不能是非 <code>const</code> 的引用参数</p><p>输出参数为指针. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;in, <span class="built_in">string</span> *out)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="4-4-函数重载"><a href="#4-4-函数重载" class="headerlink" title="4.4 函数重载"></a>4.4 函数重载</h4><p>如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 <code>AppendString()</code> 和 <code>AppendInt()</code> 等, 而不是一口气重载多个 <code>Append()</code>. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 <code>std::vector</code> 以便使用者可以用 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#braced-initializer-list" target="_blank" rel="noopener">列表初始化</a> 指定参数. </p><h3 id="5，其他"><a href="#5，其他" class="headerlink" title="5，其他"></a>5，其他</h3><h4 id="5-1-使用-C-的类型转换-如-static-cast-lt-gt-不要使用int-y-int-x等转换方式"><a href="#5-1-使用-C-的类型转换-如-static-cast-lt-gt-不要使用int-y-int-x等转换方式" class="headerlink" title="5.1 使用 C++ 的类型转换, 如 static_cast&lt;&gt;(). 不要使用int y = (int)x等转换方式"></a>5.1 使用 C++ 的类型转换, 如 <code>static_cast&lt;&gt;()</code>. 不要使用int y = (int)x等转换方式</h4><h4 id="5-2-禁止使用-RTTI"><a href="#5-2-禁止使用-RTTI" class="headerlink" title="5.2 禁止使用 RTTI."></a>5.2 禁止使用 RTTI.</h4><h4 id="5-3-不使用-C-异常"><a href="#5-3-不使用-C-异常" class="headerlink" title="5.3 不使用 C++ 异常."></a>5.3 不使用 C++ 异常.</h4><h4 id="5-4-只在记录日志时使用流"><a href="#5-4-只在记录日志时使用流" class="headerlink" title="5.4 只在记录日志时使用流."></a>5.4 只在记录日志时使用流.</h4><p>不要使用流, 除非是日志接口需要. 使用 <code>printf</code> 之类的代替.</p><h4 id="5-5-对于迭代器和其他模板对象使用前缀形式-i-的自增-自减运算符"><a href="#5-5-对于迭代器和其他模板对象使用前缀形式-i-的自增-自减运算符" class="headerlink" title="5.5 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符."></a>5.5 对于迭代器和其他模板对象使用前缀形式 (<code>++i</code>) 的自增, 自减运算符.</h4><p>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减)，不考虑返回值的话, 前置自增 (<code>++i</code>) 通常要比后置自增 (<code>i++</code>) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 <code>i</code> 进行一次拷贝. 如果 <code>i</code> 是迭代器或其他非数值类型, 拷贝的代价是比较大的.</p><h4 id="5-6-const"><a href="#5-6-const" class="headerlink" title="5.6 const"></a>5.6 const</h4><p>const变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误.</p><p>注意初始化 const 对象时，必须在初始化的同时值初始化。</p><p> <strong>我们强烈建议在任何可能的情况下使用 const</strong></p><ul><li>如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 <code>const</code>.</li><li>尽可能将函数声明为 <code>const</code>. 访问函数应该总是 <code>const</code>. 其他不会修改任何数据成员, 未调用非 <code>const</code> 函数, 不会返回数据成员非 <code>const</code> 指针或引用的函数也应该声明成 <code>const</code>.</li><li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 <code>const</code>.</li></ul><h4 id="5-7-constexpr"><a href="#5-7-constexpr" class="headerlink" title="5.7 constexpr"></a>5.7 constexpr</h4><p>变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 constexpr, 以用来定义 constexpr 变量</p><h4 id="5-8-预处理宏"><a href="#5-8-预处理宏" class="headerlink" title="5.8 预处理宏"></a>5.8 预处理宏</h4><p>用宏展开性能关键的代码, 现在可以用<strong>内联函数</strong>替代. </p><p>用宏表示常量可被<strong>const变量</strong>代替. </p><p>用宏 “缩写” 长变量名可被<strong>引用</strong>代替.</p><p>使用宏时，应遵守：</p><ul><li>不要在 <code>.h</code> 文件中定义宏.</li><li>在马上要使用时才进行 <code>#define</code>, 使用后要立即 <code>#undef</code>.</li><li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li><li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li><li>不要用 <code>##</code> 处理函数，类和变量的名字。</li></ul><h4 id="5-9-零值"><a href="#5-9-零值" class="headerlink" title="5.9 零值"></a>5.9 零值</h4><p>整数用 <code>0</code>, 实数用 <code>0.0</code>, 指针用 <code>nullptr</code> 或 <code>NULL</code>, 字符 (串) 用 <code>&#39;\0&#39;</code>.</p><h4 id="5-10-尽可能用-sizeof-varname-代替-sizeof-type"><a href="#5-10-尽可能用-sizeof-varname-代替-sizeof-type" class="headerlink" title="5.10 尽可能用 sizeof(varname) 代替 sizeof(type)."></a>5.10 尽可能用 <code>sizeof(varname)</code> 代替 <code>sizeof(type)</code>.</h4><h3 id="6，命名规范"><a href="#6，命名规范" class="headerlink" title="6，命名规范"></a>6，命名规范</h3><h4 id="6-1-文件命名"><a href="#6-1-文件命名" class="headerlink" title="6.1 文件命名"></a>6.1 文件命名</h4><p>文件名要全部小写, 可以包含下划线 (<code>_</code>) </p><h4 id="6-2-类型命名"><a href="#6-2-类型命名" class="headerlink" title="6.2 类型命名"></a>6.2 类型命名</h4><p>类型名称的每个单词首字母均大写, 不包含下划线: <code>MyExcitingClass</code>, <code>MyExcitingEnum</code></p><h4 id="6-3-变量命名"><a href="#6-3-变量命名" class="headerlink" title="6.3 变量命名"></a>6.3 变量命名</h4><p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接，</p><p><strong>类的成员变量以下划线结尾</strong>，但结构体的就不用。</p><p>如: <code>a_local_variable</code>, <code>a_struct_data_member</code>, <code>a_class_data_member_</code>.</p><h4 id="6-4-常量命名"><a href="#6-4-常量命名" class="headerlink" title="6.4 常量命名"></a>6.4 常量命名</h4><p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以<strong>k</strong>开头, 大小写混合. 例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h4 id="6-5-函数命名"><a href="#6-5-函数命名" class="headerlink" title="6.5 函数命名"></a>6.5 函数命名</h4><p>一般来说, 函数名的每个单词首字母大写，没有下划线。</p><p>对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 <code>StartRpc()</code> 而非 <code>StartRPC()</code>).</p><h4 id="6-6-命名空间"><a href="#6-6-命名空间" class="headerlink" title="6.6 命名空间"></a>6.6 命名空间</h4><p>命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p><p>顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p><p>注意 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#general-naming-rules" target="_blank" rel="noopener">不使用缩写作为名称</a> 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.</p><h3 id="7，格式"><a href="#7，格式" class="headerlink" title="7，格式"></a>7，格式</h3><h4 id="7-1-每一行代码字符数不超过-80"><a href="#7-1-每一行代码字符数不超过-80" class="headerlink" title="7.1 每一行代码字符数不超过 80."></a>7.1 每一行代码字符数不超过 80.</h4><h4 id="7-2-尽量不使用非-ASCII-字符-使用时必须使用-UTF-8-编码"><a href="#7-2-尽量不使用非-ASCII-字符-使用时必须使用-UTF-8-编码" class="headerlink" title="7.2 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码."></a>7.2 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</h4><h4 id="7-3-函数声明与调用"><a href="#7-3-函数声明与调用" class="headerlink" title="7.3 函数声明与调用"></a>7.3 函数声明与调用</h4><p>返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#function-calls" target="_blank" rel="noopener">函数调用</a> 一致.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同一行文本太多, 放不下所有参数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,</span><br><span class="line">                                             Type par_name3) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReturnType LongClassName::ReallyReallyReallyLongFunctionName(</span><br><span class="line">    Type par_name1,  <span class="comment">// 4 space indent</span></span><br><span class="line">    Type par_name2,</span><br><span class="line">    Type par_name3) &#123;</span><br><span class="line">  DoSomething();  <span class="comment">// 2 space indent</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>使用好的参数名.</li><li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li><li>如果返回类型和函数名在一行放不下, 分行.</li><li>如果返回类型与函数声明或定义分行了, 不要缩进.</li><li>左圆括号总是和函数名在同一行.</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li><li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li><li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li><li>右圆括号和左大括号间总是有一个空格.</li><li>所有形参应尽可能对齐.</li><li>缺省缩进为 2 个空格.</li><li>换行后的参数保持 4 个空格的缩进.</li></ul><h4 id="7-4-条件语句"><a href="#7-4-条件语句" class="headerlink" title="7.4 条件语句"></a>7.4 条件语句</h4><p>注意所有情况下 <code>if</code> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( condition ) &#123;  <span class="comment">// 圆括号与空格紧邻 - 不常见</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( condition2 ) &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  foo;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-5-循环语句与switch"><a href="#7-5-循环语句与switch" class="headerlink" title="7.5 循环语句与ｓｗｉｔｃｈ"></a>7.5 循环语句与ｓｗｉｔｃｈ</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></span><br><span class="line">    ...      <span class="comment">// 4 空格缩进</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 反复循环直到条件失效.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体.</span></span><br><span class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑.</span></span><br></pre></td></tr></table></figure><h4 id="7-6-指针与引用"><a href="#7-6-指针与引用" class="headerlink" title="7.6 指针与引用"></a>7.6 指针与引用</h4><p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*, &amp;</code>) 之后不能有空格.</p><ul><li>在访问成员时, 句点或箭头前后没有空格.</li><li>指针操作符 <code>*</code> 或 <code>&amp;</code> 后没有空格.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line">x = r.y;</span><br><span class="line">x = r-&gt;y;</span><br><span class="line"><span class="comment">// 好, 空格前置.</span></span><br><span class="line"><span class="keyword">char</span> *c;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好, 空格后置.</span></span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, *y;  <span class="comment">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span></span><br><span class="line"><span class="keyword">char</span> * c;  <span class="comment">// 差 - * 两边都有空格</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp; str;  <span class="comment">// 差 - &amp; 两边都有空格.</span></span><br></pre></td></tr></table></figure><h4 id="7-7-变量与数组初始化"><a href="#7-7-变量与数组初始化" class="headerlink" title="7.7 变量与数组初始化"></a>7.7 变量与数组初始化</h4><p>用 <code>=</code>, <code>()</code> 和 <code>{}</code> 均可.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"Some Name"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"Some Name"</span>;</span><br><span class="line"><span class="built_in">string</span> name&#123;<span class="string">"Some Name"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">100</span>, <span class="number">1</span>);  <span class="comment">// 内容为 100 个 1 的向量.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">100</span>, <span class="number">1</span>&#125;;  <span class="comment">// 内容为 100 和 1 的向量.</span></span><br></pre></td></tr></table></figure><h4 id="7-8-类格式"><a href="#7-8-类格式" class="headerlink" title="7.8 类格式"></a>7.8 类格式</h4><p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每个都缩进 1 个空格.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> OtherClass &#123;</span><br><span class="line"> <span class="keyword">public</span>:      <span class="comment">// 注意有一个空格的缩进</span></span><br><span class="line">  MyClass();  <span class="comment">// 标准的两空格缩进</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</span><br><span class="line">  ~MyClass() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_some_var</span><span class="params">(<span class="keyword">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">some_var</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> some_var_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SomeInternalFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> some_var_;</span><br><span class="line">  <span class="keyword">int</span> some_other_var_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li><li>关键词 <code>public:</code>, <code>protected:</code>, <code>private:</code> 要缩进 1 个空格.</li><li>除第一个关键词 (一般是 <code>public</code>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li><li>这些关键词后不要保留空行.</li><li><code>public</code> 放在最前面, 然后是 <code>protected</code>, 最后是 <code>private</code>.</li><li>关于声明顺序的规则请参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#declaration-order" target="_blank" rel="noopener">声明顺序</a> 一节.</li></ul><h4 id="7-9-初始化列表"><a href="#7-9-初始化列表" class="headerlink" title="7.9 初始化列表"></a>7.9 初始化列表</h4><p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var) : some_var_(var) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var), some_other_var_(var + <span class="number">1</span>) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var),             <span class="comment">// 4 space indent</span></span><br><span class="line">      some_other_var_(var + <span class="number">1</span>) &#123;  <span class="comment">// lined up</span></span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行</span></span><br><span class="line"><span class="comment">// 如果这样做合适的话</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="7-10-命名空间"><a href="#7-10-命名空间" class="headerlink" title="7.10 命名空间"></a>7.10 命名空间</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 正确. 命名空间内没有额外的缩进.</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不要在命名空间内缩进</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错, 缩进多余了.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><p>通用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前总是有空格.</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格.</span></span><br><span class="line"><span class="comment">// 列表初始化中大括号内的空格是可选的.</span></span><br><span class="line"><span class="comment">// 如果加了空格, 那么两边都要加上.</span></span><br><span class="line"><span class="keyword">int</span> x[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 对于单行函数的实现, 在大括号内加上空格</span></span><br><span class="line">  <span class="comment">// 然后是函数实现</span></span><br><span class="line">  Foo(<span class="keyword">int</span> b) : Bar(), baz_(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话, 不加空格.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用括号把大括号与实现分开.</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> ( i ) &#123;    <span class="comment">// 循环和条件语句的圆括号里可以与空格紧邻.</span></span><br><span class="line"><span class="keyword">if</span> ( test ) &#123;     <span class="comment">// 圆括号, 但这很少见. 总之要一致.</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格.</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码, 加个空格.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值运算符前后总是有空格.</span></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span></span><br><span class="line"><span class="comment">// 圆括号内部没有紧邻空格.</span></span><br><span class="line">v = w * x + y / z;</span><br><span class="line">v = w*x + y/z;</span><br><span class="line">v = w * (x + z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在参数和一元操作符之间不加空格.</span></span><br><span class="line">x = <span class="number">-5</span>;</span><br><span class="line">++x;</span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; x;</span><br><span class="line">y = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span> *&gt; x;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; Google编程规范：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;Google的C++开源项目编程规范&lt;br&gt;
    
    </summary>
    
      <category term="基础学习" scheme="https://itsma.github.io/categories/Base/"/>
    
    
      <category term="Base" scheme="https://itsma.github.io/tags/Base/"/>
    
  </entry>
  
  <entry>
    <title>catkin_make ERROR</title>
    <link href="https://itsma.github.io/%5Bobject%20Object%5D/catkinerror.html"/>
    <id>https://itsma.github.io/[object Object]/catkinerror.html</id>
    <published>2018-07-16T02:12:38.000Z</published>
    <updated>2018-08-01T09:00:37.881Z</updated>
    
    <content type="html"><![CDATA[<p><strong> catkin_make ERROR：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>编写完节点源代码后，catkin-make编译包时出现的错误分析。<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="CMakelist-txt参数"><a href="#CMakelist-txt参数" class="headerlink" title="CMakelist.txt参数"></a>CMakelist.txt参数</h2><h3 id="project"><a href="#project" class="headerlink" title="project()"></a>project()</h3><p>包的名字，根据catkin_create_pkg后面的名字命名。注意需要与后面的参数对准。</p><h3 id="find-package"><a href="#find-package" class="headerlink" title="find_package()"></a>find_package()</h3><p>编译包需要的依赖项。可以自己添加。格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS //必须的</span><br><span class="line">  x  //根据自己编写的源代码需要的依赖项</span><br><span class="line">  y</span><br><span class="line">  z</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories()"></a>include_directories()</h3><p>如果包有头文件，需要注意该选项。格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include_directories(</span><br><span class="line">  include $&#123;catkin_INCLUDE_DIRS&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="add-executable"><a href="#add-executable" class="headerlink" title="add_executable()"></a>add_executable()</h3><p>指定编译的文件，以及要生成的可执行文件，即节点。需要注意的是，自动生成的CMakelist文件中，会自动把节点和源文件等命名为xxx_node的格式，需要修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable($&#123;PROJECT_NAME&#125;_node src/mynode_node.cpp) //自动生成的</span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125; src/main.cpp src/file1.cpp src/file2.cpp) //正确编译的</span><br></pre></td></tr></table></figure><p>将调用src/main.cpp，src/file1.cpp和src/file2.cpp生成名为myNode的目标可执行文件</p><h3 id="target-link-libraries"><a href="#target-link-libraries" class="headerlink" title="target_link_libraries()"></a>target_link_libraries()</h3><p>指定生成的可执行文件需要链接的库文件。格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125;_node</span><br><span class="line">                      $&#123;catkin_LIBRARIES&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="错误1-Undefined-reference-to-‘’ros-init-’’"><a href="#错误1-Undefined-reference-to-‘’ros-init-’’" class="headerlink" title="错误1:Undefined reference to ‘’ros::init()’’"></a>错误1:Undefined reference to ‘’ros::init()’’</h2><p>出现该编译错误的原因很可能是</p><ul><li>头文件问题</li><li>CMakelist.txt问题</li></ul><h3 id="头文件问题"><a href="#头文件问题" class="headerlink" title="头文件问题"></a>头文件问题</h3><p>检查包含的头文件，有可能写错。</p><h3 id="CMakelist-txt问题"><a href="#CMakelist-txt问题" class="headerlink" title="CMakelist.txt问题"></a>CMakelist.txt问题</h3><p>主要检查以下几个方面：project名字，依赖包是否完整，头文件夹是否包含，</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; catkin_make ERROR：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;编写完节点源代码后，catkin-make编译包时出现的错误分析。&lt;br&gt;
    
    </summary>
    
      <category term="ROS学习" scheme="https://itsma.github.io/categories/ROS/"/>
    
    
      <category term="ROS" scheme="https://itsma.github.io/tags/ROS/"/>
    
  </entry>
  
</feed>
