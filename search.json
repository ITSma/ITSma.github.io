[{"title":"分治","url":"/[object Object]/divideconquer.html","content":"<Excerpt in index | 首页摘要>\n分治法，递归求解一个问题，在每一层递归中应用**分解，解决和合并**三个步骤。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 分解\n\n将问题划分为子问题，子问题的形式与原问题一样，只是规模更小。\n\n## 解决\n\n如果子问题的规模足够小，则停止递归，直接求解\n\n## 合并\n\n将子问题的解组合成原问题的解\n\n有时除了与原问题形式完全一样的规模更小的子问题外，还需要求解与原问题不完全一样的子问题，这些可以在合并步骤完成，\n\n## 最大子数组\n\n## 二叉树遍历\n\n### 前序（根左右）\n\n####　非递归\n\n栈保存的是访问树节点的顺序，先进后出。入栈表示先不访问节点，出栈表示访问该节点。将当前指针指向的节点又看做根节点。\n\n先序遍历二叉树的时候，首先访问根结点，再访问左孩子，最后访问右孩子。\n\n在二叉树先序遍历非递归算法中:\n\n1. 先将根结点压栈，在栈不为空的时候执行循环;\n2. 让栈顶元素p出栈，访问栈顶元素p;\n3. 如果p的右孩子不为空，则让其右孩子先进栈\n4. 如果p的左孩子不为空，则再让其左孩子进栈\n\n**(注意：进栈顺序一定是先右孩子，再左孩子)**\n\n```C++\nvoid preOrder(TreeNode *t){\n    if(t==nullptr)return;\n    stack<TreeNode*> stk;\n    TreeNode *p=t;\n    stk.push(p);\n    while(!stk.empty()){\n        p=stk.top();\n        stk.pop();\n        cout<<p->val<<\" \";//访问根节点\n        //注意入栈顺序\n        if(p->right)stk.push(p->right);//右子节点先入栈\n        if(p->left)stk.push(p->left);\n    }\n}\n\nvoid preOrder(TreeNode *t){\n    if(t==nullptr)return;\n    stack<TreeNode*> stk;\n    TreeNode *p=t;\n    while(p!=nullptr||!stk.empty()){\n        while(p!=nullptr){\n            cout<<p->val<<\" \";//先访问根节点\n            stk.push(p);\n            p=p->left;  //再访问左子节点\n        }\n        if(!stk.empty()){\n            p=stk.top();\n            stk.pop();\n            p=p->right; //右节点进行同样的操作，可以为空节点\n        }\n        \n    }\n}\n```\n\n\n\n### 中序（左根右）\n\n#### 非递归\n\n栈保存的是访问树节点的顺序，先进后出。入栈表示先不访问节点，出栈表示访问该节点。将当前指针指向的节点又看做根节点。\n\n中序遍历的顺序是从最左节点开始的，所以需要将根节点的左节点全部入栈，直到最左节点(即左子节点为空)也入栈，将最左节点出栈进行访问，然后将当前的指针P指向栈顶结点的右孩子，使其作为根节点继续相同的处理。\n\n1. 刚开始指针指向树的根节点。将节点入栈后将指针指向左子节点，表示的是优先访问左子节点，先不访问根节点。\n2. 继续入栈根节点，直到左子节点为空，就表示没有左子树了。\n3. 将栈顶元素出栈，表示访问该节点，即左子节点为空的根节点。\n4. 按照中序遍历规则，输出该节点。\n5. 将指针指向该节点的右子节点，表示访问右子树。继续遍历。\n\n```C++\nvoid InOrder_NoRecur(TreeNode *t){\n    if(t==nullptr)return;\n    stack<TreeNode*> stk;\n    TreeNode *p=t;\n    while(p!=nullptr||!stk.empty()){\n        while(p!=nullptr){//将节点的左子树全部遍历\n            stk.push(p);\n            p=p->left;\n        }\n        if(!stk.empty()){\n            p=stk.top();  //添加空栈判断加强鲁邦性if(!stk.empty()){}\n            stk.pop();\n            cout<<p->val<<\" \";\n            p=p->right;　//转换到右节点，可以为空节点          \n        }\n    }\n}\n```\n\n[参考](https://www.cnblogs.com/SHERO-Vae/p/5800363.html)\n\n### 后序（左右根）\n\n#### 非递归\n\n后序遍历的非递归实现是三种遍历方式中最难的一种。\n\n后序遍历也是最左节点开始遍历，所以需要从根结点开始，将所有**最左结点**全部压栈，每当一个结点出栈时，都先扫描该结点的右子树，只有当一个结点的左孩子和右孩子结点均被访问过了，才能访问结点自身。\n\n辅助变量：\n\n+ ｆｌａｇ＝１表示当前结点的左孩子为空或者已被访问\n+ ＴｒｅｅＮｏｄｅ　*ｐｒｅ：表示之前访问的节点\n\n```C++\nvoid postOrder(TreeNode *t){\n    if(t==nullptr)return;\n    stack<TreeNode*> stk;\n    TreeNode *p=t;  //当前指针指向的节点\n    \n    int flag=0;　//标识位，用来表示左子节点已经被访问　或者　左子节点为空\n    TreeNode *pre;  //前驱节点，表示访问过的节点\n    \n    do{\n        while(p!=nullptr){　//所有最左节点入栈，从最左节点开始\n            stk.push(p);\n            p=p->left;\n        }\n        flag=1;\n        pre=nullptr;　//指向当前节点的前驱节点\n        while(!stk.empty() && flag==1){　//当左子树已经被访问或者为空时，存在两种情况：\n            p=stk.top(); //只获取栈顶元素，不出栈访问。因为还存在两种情况：\n            if(p->right==pre){ //１：节点的右子节点为空　或者　右子节点已经被访问过\n                stk.pop();　//出栈访问该节点\n                cout<<p->val<<\" \";　\n                pre=p;　　//表示该节点访问过了\n            } else {//２：右子节点不为空，则先处理右子节点\n                p=p->right;\n                flag=0;\n            }\n        }\n    }while(!stk.empty()); //有分号，使用dowhile是因为\n}\n```\n\n该算法具有一个**特性**：就是当访问某个结点时，栈中所保存的元素正好是这个结点的所有祖先。\n\n那么知道了这个特性，我们就很容易解决下面如下问题：\n\n(1).当给定一个叶子结点，要求输出该叶子结点的所有祖先\n\n(2).输出根结点到所有叶子结点的路径\n\n(3).如果二叉树结点的值是数值，那么求每条路径上值之和，也可以利用二叉树后序遍历的非递归算法这个特性\n\n[参考](https://www.cnblogs.com/greedyco/p/7187408.html)\n\n## 二叉树深度\n\n问题：给定一个二叉树，求它的深度。\n\n**分解：**树的深度可以分解为（左子树深度＋１）（右子树深度＋１）取其中的最大值。\n\n**解决：**递归条件是空树返回０。\n\n**合并：**可以采用参数返回，也可以采用ｖｏｉｄ。\n\n```C++\nint DepthOfTree(TreeNode *t){\n    if(t==nullptr)return 0;\n    int left_depth=DepthOfTree(t->left)+1;\n    int right_depth=DepthOfTree(t->right)+1;\n    return max(left_depth,right_depth);\n}\n```\n\n\n\n## 判断平衡树（ＡＶＬ）\n\n平衡二叉树(AVL)：\n\n它或者是一颗空树；\n\n或者具有以下性质的二叉树：\n\n1. 每个节点的左子树和右子树的深度之差(平衡因子)的绝对值不超过1。\n2. 它的左子树和右子树都是一颗平衡二叉树。\n\n**分解：**根节点判断，左子节点判断，右子节点判断。这三种情况是问题一样但规模不同\n\n**解决：**空树返回真，利用求二叉树深度函数进行判断\n\n**合并：**根据ＡＶＬ树的定义，只有在左右子树深度不超过１ ＆＆ 左子树符合要求 ＆＆ 右子树也符合要求，才能返回真。\n\n**最直接的求法：**遍历二叉树，求每一个节点的左右子树深度做判断。时间复杂度是$O(N^2)$，太费时间。\n\n（1）如果二叉树为空，返回真 \n\n（2）如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假\n\n```C++\nbool IsAVL(TreeNode *t){\n    if(t==nullptr)return true;//空树返回真\n    int ld=DepthOfTree(t->left);\n    int rd=DepthOfTree(t->right);\n    if(ld-rd>=-1 && ld-rd<=1 && IsAVL(t->left) && IsAVL(t->right))return true;\n    return false;\n}\n```\n\n**$O(N)$求法**：遍历二叉树是不可避免的，所以应该在求深度的地方优化。采用后序遍历的方式（左右根），在左右子节点的时候顺便求深度即可优化算法，也就是自底向上遍历。\n\n**关键在于如何在遍历左右子节点时求深度：**递归的时候需要保存左右子树的深度信息，~~需要额外的两个变量~~。在合并的时候只需要一个变量来保存深度就可以了。\n\n```C++\nbool IsAVL(TreeNode *t,int &deep){\n    if(t==nullptr){\n        deep=0;　//deep用于保存处理节点的深度。\n        return true;\n    }\n    /*\n    bool left=IsAVL(t->left,deep);//先访问处理左子树\n    int ld=deep; //处理完左子树后的深度，也就是左子树的深度\n    bool right=IsAVL(t->right,deep);//再访问处理右子树\n    int rd=deep;　//右子树的深度\n    //处理根节点：左子树是AVL ＆＆ 右子树也是AVL ＆＆ 根节点的左右深度不超过１\n    if(left && right && ld-rd>=-1 && ld-rd<=1){\n        deep=(ld>rd)?ld+1:rd+1;  //返回上层时深度是左右子树深度的最大值要加１\n        return true;\n    }\n    return false;   \n    */\n    int ld,rd;\n    //左右子树做了递归，不用再考虑，只需考虑根节点处理\n    if(IsAVL(tree->left,ld)&&IsAVL(tree->right,rd)&&ld-rd>=-1&&ld-rd<=1){\n        deep=(ld>rd)?ld+1:rd+1;\n        return true;\n    }\n    return false;\n}\n```\n\n## BST转双向链表\n\nBST(Binary Sort Tree)，二叉排序树，又名二叉查找树，又名二叉搜索树\n\n它或者是一棵空树；\n\n或者是具有下列性质的[二叉树](http://baike.baidu.com/view/88806.htm)： \n\n1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； \n2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n3. 左、右子树也分别为二叉排序树；\n\n**题目：**输入一棵二叉搜索树，将其转换为一个排序的双向链表。要求：不能创建任何新的结点，只能调整树中结点指针的指向。\n\n分析：\n\n1. 输入：二叉树根节点指针ＴｒｅｅＮｏｄｅ　*ｒｏｏｔ\n2. 输出：双向链表，应该指明头节点，即返回一个指针指向双向链表的第一个元素，需要一个指针变量ｈｅａｄ指向头节点，该指针不能随着函数变化，所以应该设置全局指针。\n3. 递归截止：返回ｎｕｌｌｐｔｒ\n4. 将左右子节点链接起来需要知道前一个节点信息，所以需要一个变量ｐｒｅ保存前一个节点。要保证每次调用ｐｒｅ的指向不变。可以使用**指针的指针**或者**全局变量**\n5. ｐｒｅ指向前一个节点，ｃｕｒ指向当前处理的根节点，进行连接即可。\n6. 右子树进行同样的操作。也就是递归处理右子树（当前根节点变成了右子节点）\n\n```C++\nTreeNode *head=nullptr;\nvoid BSTtoList(TreeNode *t){\n    TreeNode *pre=nullptr;\n    transform(t,&pre);//取pre指针的地址，指针的指针\n}\n\nvoid transform(TreeNode *t,TreeNode **pre){\n    if(t==nullptr)return nullptr;\n    \n    transform(t->left,pre);//先处理左子树\n    \n    //\n    TreeNode *cur=t; //cur指向当前访问的节点(根节点)\n    if(*pre==nullptr){//在最左节点处\n        *pre=cur;\n        head=cur;//指向第一个指针\n    } else {//连接两个节点\n        cur->left=*pre;\n        (*pre)->right=cur;\n        *pre=cur;\n    }\n    \n    transform(t->right,pre);\n    \n}\n```\n\n\n\n","tags":["algorithm"],"categories":["算法学习"]},{"title":"排序总结","url":"/[object Object]/sort.html","content":"<Excerpt in index | 首页摘要>\n从时间复杂度，空间复杂度，稳定性和初始状态等方面分析排序算法\n<!-- more -->\n<The rest of contents | 余下全文>\n![排序算法](../../../../图片/sort.png)\n\n## 时间复杂度\n\n简单排序在已经排好序的情况下时间复杂度是最好的，在逆序的情况下是最坏的。\n\n快速排序在基准元素是最小或最大值时是最坏的。\n\n归并排序与堆排序是最稳定的。\n\n##　空间复杂度\n\n只有**归并排序和快速排序**需要额外的空间。\n\n因为采用递归的方法，递归的次数是$O(logN)$。每一次递归都需要空间。\n\n快速排序在对序列的操作过程中只需花费常数级的空间。空间复杂度$O(1)$。 但需要注意快速排序每次递归都会返回一个基准元素的下标位置，必须使用栈。递归栈上需要花费最少$logN$最多$N$的空间。\n\n归并排序每次递归需要用到一个辅助表，长度与待排序的表相等，虽然递归次数是$logN$，但每次递归都会释放掉所占的辅助空间，所以下次递归的栈空间和辅助空间与这部分释放的空间就不相关了，因而空间复杂度还是$O(N)$。\n\n归并排序需要额外的$O(N)$的空间。\n\n快速排序需要额外的$O(NlogN)$的空间。\n\n## 稳定性\n\n稳定排序：插入，冒泡，归并\n\n不稳定排序：选择，快速，堆\n\n**归并排序：**在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，**归并排序也是稳定的排序算法。**\n\n**堆排序：**在叶子节点与父节点这3个元素之间的选择最大或最小不会破坏稳定性。但在叶子节点之上的节点交换会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。\n\n**快速排序：**在基准元素与有相同元素之间交换时会破坏稳定性。（５，３，９，３，８，１０）中基准元素５与第二个３交换。\n\n**选择排序：**序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。\n\n## 初始状态\n\n算法复杂度与数组的初试状态无关：\n\n一堆（**堆排序**）乌龟（**归并排序**）选（**选择排序**）基（**基数排序**）友\n\n元素总**比较次数**与初始状态无关的有：**选择排序**、**基数排序**。\n\n元素总**移动次数**与初始状态无关的有：**归并排序**、**基数排序**","tags":["algorithm"],"categories":["算法学习"]},{"title":"堆排序","url":"/[object Object]/heapsort.html","content":"<Excerpt in index | 首页摘要>\n堆排序是利用堆的性质来对数组进行排序，主要分为**建堆**和**交换**两个步骤\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 堆\n\n堆在形式上是一棵满足一定性质的二叉树。\n\n由于二叉树良好的形态已经包含了父节点和孩子节点的关系信息，因此就可以不需要使用链表而使用**数组**来存储堆。\n\n堆分为两种，最大堆和最小堆，以最大堆为例，最大堆保持了根结点大于两个左右两个孩子，同时所有子树一次类推。例如：\n\n```C++\nint heap[]={9,8,6,7,5,3,2,1,4,0};\n```\n\n**设父节点的编号为** **i, 则其左孩子节点的编号为2\\*i+1, 右孩子节点的编号为2*i+2** \n\n**设孩子节点的编号为i, 则其父节点的编号为(i-1)/2**\n\n### 堆排序\n\n堆排序指的就是利用堆的性质对数组进行排序。\n\n**小顶堆中根节点小于两个左右子节点的性质。**\n\n将一个无序数组看做是一个完全二叉树，此时没有成堆。\n\n#### 建堆\n\n将该数组进行建堆操作，\n\n即将父节点和左右子节点三个数进行比较，最小的数作为父节点，\n\n循环操作整颗树后，根节点就是数组中最小的树。\n\n问题转化为将**树中的最小值移动至根节点**。\n\n![](http://img.chuansong.me/mmbiz_png/zrIoKPEFItdOmAIKW4mHjIkFD6zKGNLBFSEv8f6duBoE3YAyNzhUuV3woKzCPrYpibQ3icB1zvhrkSZMDKP10V0Q/?wx_fmt=png)\n\n```C++\nvoid buildHeap(vector<int> &arr,int unsortSize){//unsortSize表示未排序元素的个数\n    int rootIndex=unsortSize/2-1;//第一个非叶子节点的下标\n    for(;rootIndex>=0;rootIndex--){\n        //左右节点都存在，比较三个数，最小值与根节点交换\n        if(2*rootIndex+2<=unsortSize){//注意是小于未排序数列的大小，不是整个数列的大小\n            if(arr[2*rootIndex+1]<arr[2*rootIndex+2]){//左节点小于右节点\n                if(arr[rootIndex]>arr[2*rootIndex+1]){//左节点最小\n                    swap(arr[rootIndex],arr[2*rootIndex+1]);\n                }\n            } else {　　　//右节点小于左节点\n                if(arr[rootIndex]>arr[2*rootIndex+2]){//右节点最小\n                    swap(arr[rootIndex],arr[2*rootIndex+2]);\n                }\n            }      \n        }　else {  //右节点不存在，只比较根节点与左节点\n            if(arr[rootIndex]>arr[2*rootIndex+2]){\n                swap(arr[rootIndex],arr[2*rootIndex+2]);\n            }\n        }\n    }\n}\n```\n\n**注意建堆时节点数是小于未排序数列的大小，不是整个数列的大小**\n\n#### 交换\n\n建堆操作后，数组中的最小值就是根节点。为了循环遍历，我们将最小值与数组最后一个数进行交换。这样，除数组最后一个数之外又变成了一个**能构成完全二叉树的无序数组**。\n\n```C++\nvoid swapHeap(vector<int> &arr,int end){\n    int temp=arr[end];\n    arr[end]=arr[0];\n    arr[0]=temp;\n}\n```\n\n\n\n#### 排序\n\n堆排序就是先建立一个小根堆，然后不断地交换堆顶最小元素，交换N-1次就OK了\n\n```C++\nvoid heapSort(vector<int> &arr){\n    int size=arr.size();\n    if(size<=1)return;\n    for(int i=size;i>1;--i){//size表示未排序元素个数，当只剩一个时就退出，所以是i>1\n        buildHeap(arr,i);\n        swapHeap(arr,i);\n    }\n}\n```\n\n### 性质\n\n时间复杂度：\n\n+ 建堆复杂度为$O(logN)$\n+ 交换可以忽略\n+ 需要进行$N-1$次建堆\n\n所以，堆排序的时间复杂度是$O(N-1)*O(logN)=O(NlogN)$\n\n**不稳定排序**\n\n在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， ... 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法\n\n[参考资料](http://chuansong.me/n/2129062451005)\n\n","tags":["algorithm"],"categories":["算法学习"]},{"title":"归并排序","url":"/[object Object]/mergesort.html","content":"\n\n\n<Excerpt in index | 首页摘要>\n\n归并排序的基本思想也是分治法。与快速排序不一样的是，归并排序是先分后治，而快排是先治后分\n\n<!-- more -->\n<The rest of contents | 余下全文>\n![](../../../../图片/ms.png)\n\n可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现。\n\n### 分\n\n在**分**的阶段可以采用递归方法实现:\n\n```C++\nvoid mergeSort(int *arr,int start,int end){\n    if(start>=end)return;//递归结束条件\n    //分\n    int mid=start+(end-start)/2;//将数组从中间分开\n    mergeSort(arr,start,mid);\n    mergeSort(arr,mid+1,end);\n    //治\n    merge(arr,start,mid,end,temp);//合并两个有序数组arr[start,mid]和arr[mid+1,end]到数组temp\n}\n```\n\n### 治\n\n在**治**的阶段将问题转化为了**合并相邻有序子序列**：\n\n例如，｛８｝和｛４｝｛４，８｝和｛５，７｝｛４，５，７，８｝和｛１，２，３，６｝\n\n```C++\nvoid merge(int *arr,int start,int mid,int end,int *temp){\n    int i=start;　//左序列指针\n    int j=mid+1; //右序列指针\n    int k=0; //临时数组指针\n    while(i<=mid && j<=end){\n        temp[k++]=((arr[i]<arr[j])?arr[i++]:arr[j++]);\n    }\n    while(i<=mid){\n        temp[k++]=arr[i++];\n    }\n    while(j<=end){\n        temp[k++]=arr[j++];\n    }\n    k=0;\n    while(start<=end){　//小于等于\n        arr[start++]=arr[k++];\n    }\n}\n```\n\n### 时间复杂度：\n\n合并操作merge()的平均复杂度是**$O(N)$**\n\n拆分操作是完全二叉树的深度，时间复杂度是**$O(NlogN)$**\n\n所以，最坏、最好和平均时间复杂度都是**$O(NlogN)$**。\n\n### **稳定**排序\n\n### 优缺点\n\n缺点：需要额外的空间。开辟与arr数组一样大小的空间来存储排好的序列。\n\n[参考](https://www.cnblogs.com/chengxiao/p/6194356.html)\n\n","tags":["algorithm"],"categories":["算法学习"]},{"title":"快速排序","url":"/[object Object]/quicksort.html","content":" <Excerpt in index | 首页摘要>\n快速排序是由冒泡排序演变而来，都属于交换排序。快速排序之所以快速，是因为采用了分治法。\n<!-- more -->\n<The rest of contents | 余下全文>\n快速排序属于交换排序，通过元素之间的比较和交换位置来达到排序目的。不同的是，冒泡排序每一轮只把一个元素冒泡到数组一端，而快速排序在每一轮挑选一个基准元素，并让其他比它大的元素移动到数组一边，比它小的移动到数组另一边，从而把数组拆解成两个部分。这种思想就是分治法。\n\n在分治法的思想下，原数列在每一轮被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。\n\n这样一共需要多少轮呢？平均情况下需要$logN$轮，因此快速排序算法的平均时间复杂度是 **O(NlogN)**\n\n### 分\n\n在分的阶段，就是将基准元素左边序列和右边序列再次治理。可以用递归实现。\n\n```C++\nvoid quickSort(int *arr,int start,int end){//start指向第一个元素，end指向数组最后一个元素\n    if(start<=end)return; //递归结束条件\n    \n    //治\n    int pivotIndex=partition(arr,start,end); //进行一次快排，返回分治后基准元素在数组中的位置下标\n    \n    //分\n    qucikSort(arr,start,pivotIndex-1); //左边递归\n    quickSort(arr,pivotIndex+1,end);　//右边递归\n}\n```\n\n###　治\n\n在治的阶段，就是进行一次排序，把数组中大于基准元素的都移动到基准元素一边，大于基准元素的都移动到基准元素另一边。即partition()函数\n\npartition函数的实现方法有两种：\n\n- 挖坑法\n- 指针交换法\n\n#### 递归挖坑法\n\n两个指针start和end分别指向数组的最左和最右两个元素。\n\n1. 选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴，也是初始的坑位。\n2. 设置两个变量left = 0;right = N - 1;\n3. 从left一直向后走，直到找到一个大于key的值，然后将该数放入坑中，坑位变成了array[left]。\n4. right一直向前走，直到找到一个小于key的值，然后将该数放入坑中，坑位变成了array[right]。\n5. 重复3和4的步骤，直到left和right相遇，然后将key放入最后一个坑位。\n\n**注意，以第一个元素(start)作为基准元素时，则end先动。否则，以最后的元素(end)作为基准元素，应该(start)先动。start走的时候end是不动的，反之亦然。因为end先走，所有最后一个坑肯定在arr[start]。**\n\n```C++\n//挖坑法\nint partition(int *arr,int start,int end){\n    int pivot=arr[start]; //基准元素\n    while(start<end){\n        while(strat<end && arr[end]>=pivot ){　//大于等于\n            end--;   //保持不动\n        }\n        arr[start]=arr[end];　//填“坑”\n        //start++;\n        while(start<end && arr[start]<=pivot ){ //小于等于\n            start++;\n        }\n        arr[end]=arr[start];　//填“坑”\n        //end--;\n    }\n    arr[start]=pivot;　//将基准元素填入最后的“坑”中　此时start>=end\n    return start;\n}\n```\n\n#### 递归指针交换法\n\n两个指针left和right分别指向数组的最左start和最右end两个元素。\n\n1. 选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴。\n2. 设置两个变量left = 0;right = N - 1;\n3. 从left一直向后走，直到找到一个大于key的值，right从后至前，直至找到一个小于key的值，然后交换这两个数。\n4. 重复第三步，一直往后找，直到left和right相遇，这时将key放置left的位置即可\n\n![](../../../../图片/qs.png)\n\n```C++\nint partition(int *arr,int start,int end){\n    int pivot=arr[start];\n    int left=start; //左指针\n    int right=end; //右指针\n    while(left<right){\n        while(left<right && arr[right]>pivot ){　//没有等于号\n            right--;\n        }\n        while(left<right && arr[left]<pivot ){ //没有等于号\n            left--;\n        }\n        int temp=arr[left];\n        arr[left]=arr[right];\n        a[right]=temp;\n    }\n    int t=arr[left]; //指针重合,交换基准元素与指针位置元素\n    arr[left]=arr[start];\n    arr[start]=t\n    return left;\n}\n```\n\n### 非递归实现\n\n递归的算法主要是在划分子区间，如果要非递归实现快排，只要使用一个栈来保存区间就可以了。  一般将递归程序改成非递归首先想到的就是使用栈，因为递归本身就是一个压栈的过程。\n\n```C++\nvoid quickSort(int *arr,int start,int end){\n    if(start>end)return;\n    stack<int> stk;\n    stk.push(start);　//左指针先入栈\n    stk.push(end);\n    while(!stk.empty()){\n        int right=stk.top(); //右指针先出栈\n        stk.pop();\n        int left=stk.top();\n        stk.pop();\n        \n        int pivotIndex=partition(arr,left,right);\n        if(pivotIndex-1>left){　//注意是left还是start，\n            stk.push(start);  //注意入栈顺序，先入左边再入右边,push数组最左端的位置即start\n            stk.push(pivotIndex-1);\n        }\n        if(pivotIndex+1<right){//判断的是基准位置与排序区间，应该是partition的left和right\n            stk.push(pivotIndex+1);\n            stk.push(end);\n        }   \n    }\n}\n```\n\n### 性质\n\n**不稳定排序**\n\n比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。\n\n时间复杂度\n\n最坏：在基准元素是数组最大或者最小值时，时间复杂度是**$O(N^2)$**\n\n最好：基准元素是中间值。时间复杂度是$O(NlogN)$\n\n平均：**$O(NlogN)$**\n\n[参考](https://blog.csdn.net/qq_36528114/article/details/78667034)\n\n","tags":["algorithm"],"categories":["算法学习"]},{"title":"简单排序","url":"/[object Object]/sortalgorithm.html","content":"<Excerpt in index | 首页摘要>\n常用的排序算法分析：选择排序，冒泡排序，插入排序\n<!-- more -->\n<The rest of contents | 余下全文>\n\n### 选择排序\n\n#### 算法原理\n\n首先遍历数组找到最小（大）元素，存放到数组的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕\n\n![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif)\n\n```C++\nvoid selectSort(int a[]) {\n    int len = a.size();\n    int min_index; //需要记录最小值和下标\n    if(len <= 1)return;\n    for(int i=0;i<len;++i){\n        min_index=i;\n        for(int j=i;j<len;++j){\n            if(a[min_index]>a[j]){\n                min_index=j;\n            }\n        }\n        int temp=a[i];\n        a[i]=a[min_index];　//交换\n        a[min_index]=temp;      \n    }\n}\n```\n\n#### 性质\n\n最稳定的排序算法\n\n最坏，最好和平均时间复杂度总是$O(N^2)$\n\n### 冒泡排序\n\n#### 算法原理\n\n顺序依次相邻元素比较，大的往后移(从小到大排序)，这样能保证一轮过后最大的数在最后面。再进行一轮比较得到第二大的数，依次类推。\n\n![](../../../../图片/bubbleosrt.gif)\n\nN个数排序需要重复N-1次；\n\n第K次排序时，证明已经有K个数排好序，不需要再排。则第K次需要的比较的次数为(N-1-K)次；\n\n所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数\n\n```C++\nvoid BubbleSort(int a[]){\n    int len=a.size();\n    if(len<=1)return; //数组为空或者只有一个数\n    for(int i=0;i<len-1;i++){ //n个数需要　重复　（n-1）次\n        for(int j=0;j<len-1-i;++j){　//每一次都需要　比较　（n-1-i）次\n            if(a[j]>a[j+1])swap(a[j],a[j+1]);\n        }\n    }\n}\n```\n\n**改进**：当数组已经排好序时，可以直接跳出循环得到结果。不需要再做比较\n\n```C++\nvoid BubbleSort(int a[]){\n    int len=a.size();\n    bool flag=true; //true表示乱序，\n    if(len<=1)return; \n    for(int i=0;i<len-1 && flag;i++){ \n        flag=false;\n        for(int j=0;j<len-1-i;++j){　//如果没有进入if语句说明数组已经排好序，下次直接跳出。\n            if(a[j]>a[j+1]){\n                swap(a[j],a[j+1]);\n                flag=true; //有元素交换，则说明排序未完成。\n            }\n        }\n    }\n}\n```\n\n#### 性质\n\n时间复杂度\n\n1. 最好：$O(N)$。在数组已经是正序的情况下，只需要遍历一遍就可以跳出循环。\n2. 最坏：$O(N^2)$。在数组逆序的情况下。\n3. 平均：$O(N^2)$。\n\n**稳定排序**\n\n### 插入排序\n\n#### 算法原理\n\n对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入\n\n![](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif)\n\n```C++\nvoid insertSort(int a[]) {\n    int len = a.size();\n    if(len<=1)return;\n    for(int i=1;i<len-1;++i){\n        int j=i-1;\n        int key=a[i];\n        while( j>=0 && key>a[j] ){\n            a[j+1]=a[j];\n            --j;\n        }\n        a[j+1]=key;\n    }\n}\n```\n\n#### 性质\n\n时间复杂度：\n\n1. 最好：$O(N)$。已经排好序的数组。遍历一遍。\n2. 最坏：$O(N^2)$。逆序\n3. 平均：$O(N^2)$。\n\n**不稳定排序：**\n\n序列5 8 5 2 9，第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。\n\n\n\n[参考](https://www.cnblogs.com/onepixel/articles/7674659.html)","tags":["algorithm"],"categories":["算法学习"]},{"title":"Google浏览器插件","url":"/[object Object]/webtools.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n适合自己的才是最好的。个人常用插件集合\n<!-- more -->\n<The rest of contents | 余下全文>\n\n## 书签\n\n书签管理\n\n## 新标签页\n\nInfinity新标签页\n\n## 快捷键\n\nSurfingkeys\n\n## 网络代理\n\nProxy SwitchyOmega\n\n## 下载\n\nYAAW for Chrome\n\n## 翻译\n\n有道词典Chrome划词插件\n\n## 购物\n\n购物党全网比价工具","tags":["Devtools"],"categories":["开发工具"]},{"title":"Google编程规范","url":"/[object Object]/googleGuide.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nGoogle的C++开源项目编程规范\n<!-- more -->\n<The rest of contents | 余下全文>\n## C++编程规范\n\n### 1，头文件\n\n#### 1.1 头文件可以自给自足，可以作为第一个引入的头文件\n\n#### 1.2 define保护\n\n项目 `foo` 中的头文件 `foo/src/bar/hd.h` 可按如下方式保护:\n\n```C++\n#ifndef FOO_BAR_HD_H_\n#define FOO_BAR_HD_H_\n...\n#endif  //FOO_BAR_HD_H_\n```\n\n#### 1.3 尽量避免使用前置声明。使用 `#include` 包含需要的头文件即可。\n\n前置声明就是我在声明一个类（CHouse）的时候，用到了另外一个类的定义（CBed），但是CBed还没有定义呢，而且我还先不需要CBed的定义，只要知道CBed是一个类就够了。那好，我就先声明类CBed，告诉编译器CBed是一个类（不用包含CBed的头文件，然后在CHouse中用到CBed的，都用CBed的指针类型代（因为指针类型固定大小的，但是CBed的大小只用知道了CBed定义才能确定）。等到要实现CHouse定义的时候，就必须要知道CBed的定义了，那是再包好CBed的头文件就行了。\n\n+ 尽量避免前置声明那些定义在其他项目中的实体.\n+ 函数：总是使用 `#include`.\n+ 类模板：优先使用 `#include`.\n\n#### 1.4 只有当函数少于10行时才将其定义为内联函数.\n\n当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.\n\n不内联的情况：\n\n+ 循环或switch语句\n+ 析构函数，虚函数，递归函数\n\n内联函数必须放在 `.h` 文件中. 如果内联函数比较短, 就直接放在 `.h` 中.\n\n#### 1.5 #include的路径和顺序\n\n`dir/foo.cc` 或 `dir/foo_test.cc` 的主要作用是实现或测试 `dir2/foo2.h` 的功能, `foo.cc` 中包含头文件的次序如下:\n\n1. cpp直接的头文件(dir2/foo2.h)\n2. C库\n3. C++库\n4. 其他库的头文件\n5. 项目内的头文件\n\n这种优先的顺序排序保证当 `dir2/foo2.h` 遗漏某些必要的库时， `dir/foo.cc` 或 `dir/foo_test.cc` 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。\n\n按字母顺序分别对每种类型的头文件进行二次排序是不错的主意\n\n您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，哪怕您所包含的 `foo.h` 已经包含了 `bar.h`, 也照样得包含 `bar.h`, 除非 `foo.h` 有明确说明它会自动向您提供 `bar.h` 中的 symbol. \n\n### 2，作用域\n\n#### 2.1 命名空间\n\n禁止使用using\n\n```C++\n// .h 文件\nnamespace mynamespace {\n\n// 所有声明都置于命名空间中\n// 注意不要使用缩进\nclass MyClass {\n    public:\n    ...\n    void Foo();\n};\n\n} // namespace mynamespace\n```\n\n```C++\n// .cc 文件\nnamespace mynamespace {\n\n// 函数定义都置于命名空间中\nvoid MyClass::Foo() {\n    ...\n}\n\n} // namespace mynamespace\n```\n\n#### 2.2 匿名命名空间\n\n```C++\nnamespace {\n...\n}  // 匿名命名空间，编译器自动生成唯一名字\n```\n\n\n\n推荐、鼓励在 `.cc` 中对于不需要在其他地方引用的标识符使用**内部链接性声明** （匿名命名空间和static），但是不要在 `.h` 中使用。\n\n所有置于匿名命名空间的声明都具有内部链接性，名称的作用域被限制在当前文件中，无法通过在另外的文件中使用extern声明来进行链接\n\n函数和变量可以经由声明为 `static` 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。\n\n#### 2.3 静态成员函数与命名空间非成员函数\n\n**尽量不要使用全局函数，非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内，不要使用静态成员方法，类的静态方法应当和类的实例或静态数据紧密相关.**\n\n```C++\nnamespace myproject {\nnamespace foo_bar {\nvoid Function1();\nvoid Function2();  //非成员函数应置于命名空间中\n}  // namespace foo_bar\n}  // namespace myproject\n```\n\n```C++\nnamespace myproject {\nclass FooBar {\n public:\n  static void Function1();\n  static void Function2();\n};\n}  // namespace myproject\n```\n\n#### 2.4 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化,离第一次使用越近越好\n\n```C++\n//Not Like This\nint i;\ni = f(); // 坏——初始化和声明分离\n\n//Better Like This\nint j = g(); // 好——初始化时声明\n```\n\nif, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了\n\n```C++\nwhile (const char* p = strchr(str, '/')) str = p + 1;\n```\n\n有一个例外, 如果**变量是一个对象**, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低，这时应该在循环作用域外面声明这类变量:\n\n```C++\n// 低效的实现\nfor (int i = 0; i < 1000000; ++i) {\n    Foo f;                  // 构造函数和析构函数分别调用 1000000 次!\n    f.DoSomething(i);\n}\n\nFoo f;                      // 构造函数和析构函数只调用 1 次\nfor (int i = 0; i < 1000000; ++i) {\n    f.DoSomething(i);\n}\n```\n\n#### 2.5 静态和全局变量\n\n尽量不用全局函数和全局变量,\n\n多线程中的全局变量 (含静态成员变量) 不要使用 `class` 类型 (含 STL 容器), 因为构造和析构顺序的不确定导致不明确行为导致的 bug.\n\n静态生存周期的对象，即包括了**全局变量，静态变量，静态类成员变量和函数静态变量**，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。即**完全禁用类类型的全局变量**，比如vector(使用 C 数组替代) 和string(使用 `const char []`)。我们也**不允许用函数返回值来初始化 POD 变量**，除非该函数不涉及任何全局变量。\n\n### 3，类\n\n#### 3.1 不要在构造函数中调用虚函数\n\n如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.\n\n#### 3.2 对于单参数构造函数, 请使用explicit关键字来禁止隐式转换\n\n#### 3.3 移动构造函数，移动赋值函数和拷贝构造函数，拷贝赋值函数\n\n```C++\n//拷贝构造函数\nclass ClassName{\n    int *a;\npublic:\n    ClassName(){}     //构造函数\n    ClassName(int x){}  //有参数的构造函数\n    ~ClassName(){delete *a}  //析构函数\n    \n    ClassName(const ClassName &Obj){} //拷贝构造函数\n    ClaaName& operator=(const ClassName &Obj){  //拷贝赋值函数\n        return *this;\n    }\n    \n    ClassName(ClassName &&Obj){}   //移动构造函数\n    ClassName& operator=(ClassName &Obj){  //移动赋值函数\n        return *this;\n    }\n};\n```\n\n##### 3.3.1 **拷贝构造函数:**\n\n```C++\nMyClass foo;\nMyClass bar(foo);       // 对象初始化: 调用拷贝构造函数\nMyClass baz = foo;      // 对象初始化: 调用拷贝构造函数\nfoo = bar;              // 对象已经被初始化，调用拷贝赋值\n```\n\n什么时候用到拷贝构造函数？  \n\n1. 一个对象以值传递的方式传入函数体；\n2. 一个对象以值传递的方式从函数返回； \n3. 一个对象需要通过另外一个对象进行初始化\n\n##### 3.3.2 **深拷贝**  \n\n如果一个类拥有资源，当这个类的对象发生复制过程的时候，**资源重新分配**，例如需要新开辟内存，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。\n\n如对象A=B。这时，如果B中有一个成员变量指针已经申请了内存，浅拷贝(默认拷贝构造函数)则是A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。\n\n##### 3.3.3 **移动构造函数**\n\n移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。  这里未命名的对象就是那些临时变量，甚至都不会有名称。\n\n典型的未命名对象就是**函数的返回值或者类型转换的对象**。  \n\n使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值： \n\n```c++\nMyClass fn();            // 函数返回一个 MyClass 对象\nMyClass foo;             // 默认构造函数\nMyClass bar = foo;       // 拷贝构造函数\nMyClass baz = fn();      // 移动构造函数\nfoo = bar;               // 拷贝赋值\nbaz = MyClass();         // 移动赋值 \n```\n\n##### 3.3.4 **区别:**\n\n拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。  而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。\n\n##### 3.3.5 总结\n\n如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.\n\n如果你的类不需要拷贝 / 移动操作, 请显式地通过在 `public` 域中使用 `= delete` 或其他手段禁用之.\n\n```C++\n// MyClass is neither copyable nor movable.\nMyClass(const MyClass&) = delete;\nMyClass& operator=(const MyClass&) = delete;\n```\n\n####  3.4 仅当只有数据成员时使用struct，其它一概使用class\n\n#### 3.5 继承\n\n组合 > 实现继承 > 接口继承 > 私有继承\n\n##### 3.5.1 组合\n\n组合类：一个类(Head类)里面的数据成员是另一个类的对象，即内嵌其他类的对象作为自己的成员。\n\nEye,Nose,Mouth,Ear这些类都是Head类的一部分\n\n```C++\nclass Eye{void look()};\nclass Nose{};\nclass Mouth{};\nclass Ear{};\nclass Head{\npublic:\n    void look(){\n        m_eye.look()\n    }\nprivate:\n    Eye m_eye;\n};\n```\n\n如果A类是B类的一部分，则不要让B类去继承A类，而是采用组合的形式。如果A类和B类毫无关系，我们不应该为了让B类多一个功能而去让B继承A。如果在逻辑上B是A的一种，即B类的man也是A类的 Hunman的一种我们就可以让B类去继承A类。\n\n##### 3.5.2 继承\n\n所有继承必须是 `public` 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.\n\n对于可能被子类访问的成员函数, 不要过度使用 `protected` 关键字.\n\n数据成员都必须是 [私有的](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#access-control).\n\n#####　3.5.3 虚函数\n\n能够根据**指针**所指类型调用对应的类对象，实现函数调用时的多态性。\n\n虚函数必须声明是指针才有多态，即基类的指针指向了子类的对象，虚函数调用的是子类对象的函数，不是虚函数则调用的是基类对象的函数。\n\n基类的析构函数应该是虚函数。\n\n派生类对象构造的时候先调用基类的构造函数再调用派生类的构造函数，析构的时候先调用派生类析构函数再调用基类析构函数。派生类的析构函数会只析构自己的那部分，这时候如果基类的析构函数不是虚函数，则不能调用基类的析构函数析构从基类继承来的那部分成员，所以就会出现只删一半的现象，造成内存泄漏。\n\n```C++\n//不管析构函数是否是虚函数(即是否加virtual关键词)，delete时基类和子类都会被释放；\nSubClass* pObj = new SubClass(); //子类指针指向子类对象\ndelete pObj; //析构时，调用的子类的析构，即子类的析构函数，先析构子类再析构基类\n\n\nBaseClass* pObj = new SubClass(); //基类指针指向子类对象，\npObj->dosomething();//如果dosomething()是虚函数,则调用的是子类dosomething()函数;如果dosomething()不是虚函数，则该语句调用的是基类的dosomething()函数\ndelete pObj;\n//若析构函数是虚函数(即加上virtual关键词)，delete时基类和子类都会被释放；\n//若析构函数不是虚函数(即不加virtual关键词)，delete时只释放基类，不释放子类；\n```\n\n\n\n#### 3.6 声明顺序\n\n类定义一般应以 `public:` 开始, 后跟 `protected:`, 最后是 `private:`. 省略空部分.\n\n在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: \n\n+ 类型 (包括 `typedef`, `using`和嵌套的结构体与类),\n+ 常量\n+ 工厂函数\n+ 构造函数\n+ 赋值运算符\n+ 析构函数\n+ 其他函数\n+ 数据成员\n\n不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中\n\n### 4，函数\n\n#### 4.1 参数顺序\n\n函数的参数顺序为: 输入参数在先, 后跟输出参数.\n\n #### 4.2 函数长度\n\n如果函数超过 **40 行**, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.\n\n#### 4.3 引用参数\n\n所有按引用传递的参数必须加上 `const`。\n\n输入参数是值参或 `const` 引用，输入参数可以是 `const` 指针，但决不能是非 `const` 的引用参数\n\n输出参数为指针. \n\n```C++\nvoid Foo(const string &in, string *out);\n```\n\n#### 4.4 函数重载\n\n如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 `AppendString()` 和 `AppendInt()` 等, 而不是一口气重载多个 `Append()`. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 `std::vector` 以便使用者可以用 [列表初始化](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#braced-initializer-list) 指定参数. \n\n### 5，其他\n\n#### 5.1 使用 C++ 的类型转换, 如 `static_cast<>()`. 不要使用int y = (int)x等转换方式\n\n#### 5.2 禁止使用 RTTI.\n\n#### 5.3 不使用 C++ 异常.\n\n#### 5.4 只在记录日志时使用流.\n\n不要使用流, 除非是日志接口需要. 使用 `printf` 之类的代替.\n\n#### 5.5 对于迭代器和其他模板对象使用前缀形式 (`++i`) 的自增, 自减运算符.\n\n对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减)，不考虑返回值的话, 前置自增 (`++i`) 通常要比后置自增 (`i++`) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 `i` 进行一次拷贝. 如果 `i` 是迭代器或其他非数值类型, 拷贝的代价是比较大的.\n\n#### 5.6 const\n\nconst变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误.\n\n注意初始化 const 对象时，必须在初始化的同时值初始化。\n\n **我们强烈建议在任何可能的情况下使用 const**\n\n+ 如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 `const`.\n+ 尽可能将函数声明为 `const`. 访问函数应该总是 `const`. 其他不会修改任何数据成员, 未调用非 `const` 函数, 不会返回数据成员非 `const` 指针或引用的函数也应该声明成 `const`.\n+ 如果数据成员在对象构造之后不再发生变化, 可将其定义为 `const`.\n\n#### 5.7 constexpr \n\n变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 constexpr, 以用来定义 constexpr 变量\n\n#### 5.8 预处理宏\n\n用宏展开性能关键的代码, 现在可以用**内联函数**替代. \n\n用宏表示常量可被**const变量**代替. \n\n用宏 “缩写” 长变量名可被**引用**代替.\n\n使用宏时，应遵守：\n\n+ 不要在 `.h` 文件中定义宏.\n+ 在马上要使用时才进行 `#define`, 使用后要立即 `#undef`.\n+ 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；\n+ 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.\n+ 不要用 `##` 处理函数，类和变量的名字。\n\n#### 5.9 零值\n\n整数用 `0`, 实数用 `0.0`, 指针用 `nullptr` 或 `NULL`, 字符 (串) 用 `'\\0'`.\n\n\n\n#### 5.10 尽可能用 `sizeof(varname)` 代替 `sizeof(type)`.\n\n### 6，命名规范\n\n#### 6.1 文件命名\n\n文件名要全部小写, 可以包含下划线 (`_`) \n\n#### 6.2 类型命名\n\n类型名称的每个单词首字母均大写, 不包含下划线: `MyExcitingClass`, `MyExcitingEnum`\n\n#### 6.3 变量命名\n\n变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接，\n\n**类的成员变量以下划线结尾**，但结构体的就不用。\n\n如: `a_local_variable`, `a_struct_data_member`, `a_class_data_member_`.\n\n#### 6.4 常量命名\n\n声明为 `constexpr` 或 `const` 的变量, 或在程序运行期间其值始终保持不变的, 命名时以**k**开头, 大小写混合. 例如:\n\n```C++\nconst int kDaysInAWeek = 7;\n```\n\n#### 6.5 函数命名\n\n一般来说, 函数名的每个单词首字母大写，没有下划线。\n\n对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 `StartRpc()` 而非 `StartRPC()`).\n\n#### 6.6 命名空间\n\n命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.\n\n顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.\n\n注意 [不使用缩写作为名称](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#general-naming-rules) 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.\n\n### 7，格式\n\n#### 7.1 每一行代码字符数不超过 80.\n\n#### 7.2 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.\n\n#### 7.3 函数声明与调用\n\n返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 [函数调用](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#function-calls) 一致.\n\n```C++\nReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {\n  DoSomething();\n  ...\n}\n```\n\n如果同一行文本太多, 放不下所有参数:\n\n```C++\nReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,\n                                             Type par_name3) {\n  DoSomething();\n  ...\n}\n\nReturnType LongClassName::ReallyReallyReallyLongFunctionName(\n    Type par_name1,  // 4 space indent\n    Type par_name2,\n    Type par_name3) {\n  DoSomething();  // 2 space indent\n  ...\n}\n```\n\n注意：\n\n+ 使用好的参数名.\n+ 只有在参数未被使用或者其用途非常明显时, 才能省略参数名.\n+ 如果返回类型和函数名在一行放不下, 分行.\n+ 如果返回类型与函数声明或定义分行了, 不要缩进.\n+ 左圆括号总是和函数名在同一行.\n+ 函数名和左圆括号间永远没有空格.\n+ 圆括号与参数间没有空格.\n+ 左大括号总在最后一个参数同一行的末尾处, 不另起新行.\n+ 右大括号总是单独位于函数最后一行, 或者与左大括号同一行.\n+ 右圆括号和左大括号间总是有一个空格.\n+ 所有形参应尽可能对齐.\n+ 缺省缩进为 2 个空格.\n+ 换行后的参数保持 4 个空格的缩进.\n\n#### 7.4 条件语句\n\n注意所有情况下 `if` 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:\n\n```C++\nif ( condition ) {  // 圆括号与空格紧邻 - 不常见\n  ...  // 2 空格缩进.\n} else if ( condition2 ) {  // else 与 if 的右括号同一行.\n  ...\n} else {\n  ...  \n}\n\n// 只要其中一个分支用了大括号, 两个分支都要用上大括号.\nif (condition) {\n  foo;\n} else {\n  bar;\n}\n```\n\n#### 7.5 循环语句与ｓｗｉｔｃｈ\n\n```C++\nswitch (var) {\n  case 0: {  // 2 空格缩进\n    ...      // 4 空格缩进\n    break;\n  }\n  case 1: {\n    ...\n    break;\n  }\n  default: {\n    assert(false);\n  }\n}\n\n\nwhile (condition) {\n  // 反复循环直到条件失效.\n}\nfor (int i = 0; i < kSomeNumber; ++i) {}  // 可 - 空循环体.\nwhile (condition) continue;  // 可 - contunue 表明没有逻辑.\n```\n\n#### 7.6 指针与引用\n\n句点或箭头前后不要有空格. 指针/地址操作符 (`*, &`) 之后不能有空格.\n\n- 在访问成员时, 句点或箭头前后没有空格.\n- 指针操作符 `*` 或 `&` 后没有空格.\n\n```C++\nx = *p;\np = &x;\nx = r.y;\nx = r->y;\n// 好, 空格前置.\nchar *c;\nconst string &str;\n\n// 好, 空格后置.\nchar* c;\nconst string& str;\n\nint x, *y;  // 不允许 - 在多重声明中不能使用 & 或 *\nchar * c;  // 差 - * 两边都有空格\nconst string & str;  // 差 - & 两边都有空格.\n```\n\n#### 7.7 变量与数组初始化\n\n用 `=`, `()` 和 `{}` 均可.\n\n```C++\nint x = 3;\nint x(3);\nint x{3};\nstring name(\"Some Name\");\nstring name = \"Some Name\";\nstring name{\"Some Name\"};\n\nvector<int> v(100, 1);  // 内容为 100 个 1 的向量.\nvector<int> v{100, 1};  // 内容为 100 和 1 的向量.\n```\n\n#### 7.8 类格式\n\n访问控制块的声明依次序是 `public:`, `protected:`, `private:`, 每个都缩进 1 个空格.\n\n```C++\nclass MyClass : public OtherClass {\n public:      // 注意有一个空格的缩进\n  MyClass();  // 标准的两空格缩进\n  explicit MyClass(int var);\n  ~MyClass() {}\n\n  void SomeFunction();\n  void SomeFunctionThatDoesNothing() {\n  }\n\n  void set_some_var(int var) { some_var_ = var; }\n  int some_var() const { return some_var_; }\n\n private:\n  bool SomeInternalFunction();\n\n  int some_var_;\n  int some_other_var_;\n};\n```\n\n注意：\n\n+ 所有基类名应在 80 列限制下尽量与子类名放在同一行.\n+ 关键词 `public:`, `protected:`, `private:` 要缩进 1 个空格.\n+ 除第一个关键词 (一般是 `public`) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.\n+ 这些关键词后不要保留空行.\n+ `public` 放在最前面, 然后是 `protected`, 最后是 `private`.\n+ 关于声明顺序的规则请参考 [声明顺序](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#declaration-order) 一节.\n\n#### 7.9 初始化列表\n\n构造函数初始化列表放在同一行或按四格缩进并排多行.\n\n```C++\n// 如果所有变量能放在同一行:\nMyClass::MyClass(int var) : some_var_(var) {\n  DoSomething();\n}\n\n// 如果不能放在同一行,\n// 必须置于冒号后, 并缩进 4 个空格\nMyClass::MyClass(int var)\n    : some_var_(var), some_other_var_(var + 1) {\n  DoSomething();\n}\n\n// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行\n// 并逐行对齐\nMyClass::MyClass(int var)\n    : some_var_(var),             // 4 space indent\n      some_other_var_(var + 1) {  // lined up\n  DoSomething();\n}\n\n// 右大括号 } 可以和左大括号 { 放在同一行\n// 如果这样做合适的话\nMyClass::MyClass(int var)\n    : some_var_(var) {}\n```\n\n#### 7.10 命名空间\n\n```C++\nnamespace {\n\nvoid foo() {  // 正确. 命名空间内没有额外的缩进.\n  ...\n}\n\n}  // namespace\n\n//不要在命名空间内缩进\nnamespace {\n\n  // 错, 缩进多余了.\n  void foo() {\n    ...\n  }\n\n}  // namespace\n```\n\n通用\n\n```C++\n\nvoid f(bool b) {  // 左大括号前总是有空格.\n  ...\nint i = 0;  // 分号前不加空格.\n// 列表初始化中大括号内的空格是可选的.\n// 如果加了空格, 那么两边都要加上.\nint x[] = { 0 };\nint x[] = {0};\n\n// 继承与初始化列表中的冒号前后恒有空格.\nclass Foo : public Bar {\n public:\n  // 对于单行函数的实现, 在大括号内加上空格\n  // 然后是函数实现\n  Foo(int b) : Bar(), baz_(b) {}  // 大括号里面是空的话, 不加空格.\n  void Reset() { baz_ = 0; }  // 用括号把大括号与实现分开.\n  ...\n```\n\n```C++\nif (b) {          // if 条件语句和循环语句关键字后均有空格.\n} else {          // else 前后有空格.\n}\nwhile (test) {}   // 圆括号内部不紧邻空格.\nswitch (i) {\nfor (int i = 0; i < 5; ++i) {\nswitch ( i ) {    // 循环和条件语句的圆括号里可以与空格紧邻.\nif ( test ) {     // 圆括号, 但这很少见. 总之要一致.\nfor ( int i = 0; i < 5; ++i ) {\nfor ( ; i < 5 ; ++i) {  // 循环里内 ; 后恒有空格, ;  前可以加个空格.\nswitch (i) {\n  case 1:         // switch case 的冒号前无空格.\n    ...\n  case 2: break;  // 如果冒号有代码, 加个空格.\n```\n\n```c++\n// 赋值运算符前后总是有空格.\nx = 0;\n\n// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.\n// 圆括号内部没有紧邻空格.\nv = w * x + y / z;\nv = w*x + y/z;\nv = w * (x + z);\n\n// 在参数和一元操作符之间不加空格.\nx = -5;\n++x;\nif (x && !y)\n  ...\n```\n\n```C++\n// 尖括号(< and >) 不与空格紧邻, < 前没有空格, > 和 ( 之间也没有.\nvector<string> x;\ny = static_cast<char*>(x);\n\n// 在类型与指针操作符之间留空格也可以, 但要保持一致.\nvector<char *> x;\n```\n\n","tags":["Base"],"categories":["基础学习"]},{"title":"catkin_make ERROR","url":"/[object Object]/catkinerror.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n编写完节点源代码后，catkin-make编译包时出现的错误分析。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## CMakelist.txt参数\n\n### project()\n\n包的名字，根据catkin_create_pkg后面的名字命名。注意需要与后面的参数对准。\n\n### find_package()\n\n编译包需要的依赖项。可以自己添加。格式为：\n\n```\nfind_package(catkin REQUIRED COMPONENTS //必须的\n  x  //根据自己编写的源代码需要的依赖项\n  y\n  z\n)\n```\n### include_directories()\n\n如果包有头文件，需要注意该选项。格式为：\n\n```\ninclude_directories(\n  include ${catkin_INCLUDE_DIRS}\n)\n```\n\n### add_executable()\n\n指定编译的文件，以及要生成的可执行文件，即节点。需要注意的是，自动生成的CMakelist文件中，会自动把节点和源文件等命名为xxx_node的格式，需要修改。\n\n```\nadd_executable(${PROJECT_NAME}_node src/mynode_node.cpp) //自动生成的\nadd_executable(${PROJECT_NAME} src/main.cpp src/file1.cpp src/file2.cpp) //正确编译的\n```\n将调用src/main.cpp，src/file1.cpp和src/file2.cpp生成名为myNode的目标可执行文件\n\n### target_link_libraries()\n\n指定生成的可执行文件需要链接的库文件。格式为：\n\n```\ntarget_link_libraries(${PROJECT_NAME}_node\n                      ${catkin_LIBRARIES}\n)\n\n```\n\n## 错误1:Undefined reference to ''ros::init()''\n\n\n出现该编译错误的原因很可能是\n+ 头文件问题\n+ CMakelist.txt问题\n\n### 头文件问题\n检查包含的头文件，有可能写错。\n\n### CMakelist.txt问题\n主要检查以下几个方面：project名字，依赖包是否完整，头文件夹是否包含，\n","tags":["ROS"],"categories":["ROS学习"]}]