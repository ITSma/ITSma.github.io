[{"title":"Google编程规范","url":"/[object Object]/googleGuide.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nGoogle的C++开源项目编程规范\n<!-- more -->\n<The rest of contents | 余下全文>\n## C++编程规范\n\n### 1，头文件\n\n#### 1.1 头文件可以自给自足，可以作为第一个引入的头文件\n\n#### 1.2 define保护\n\n项目 `foo` 中的头文件 `foo/src/bar/hd.h` 可按如下方式保护:\n\n```C++\n#ifndef FOO_BAR_HD_H_\n#define FOO_BAR_HD_H_\n...\n#endif  //FOO_BAR_HD_H_\n```\n\n#### 1.3 尽量避免使用前置声明。使用 `#include` 包含需要的头文件即可。\n\n前置声明就是我在声明一个类（CHouse）的时候，用到了另外一个类的定义（CBed），但是CBed还没有定义呢，而且我还先不需要CBed的定义，只要知道CBed是一个类就够了。那好，我就先声明类CBed，告诉编译器CBed是一个类（不用包含CBed的头文件，然后在CHouse中用到CBed的，都用CBed的指针类型代（因为指针类型固定大小的，但是CBed的大小只用知道了CBed定义才能确定）。等到要实现CHouse定义的时候，就必须要知道CBed的定义了，那是再包好CBed的头文件就行了。\n\n+ 尽量避免前置声明那些定义在其他项目中的实体.\n+ 函数：总是使用 `#include`.\n+ 类模板：优先使用 `#include`.\n\n#### 1.4 只有当函数少于10行时才将其定义为内联函数.\n\n当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.\n\n不内联的情况：\n\n+ 循环或switch语句\n+ 析构函数，虚函数，递归函数\n\n内联函数必须放在 `.h` 文件中. 如果内联函数比较短, 就直接放在 `.h` 中.\n\n#### 1.5 #include的路径和顺序\n\n`dir/foo.cc` 或 `dir/foo_test.cc` 的主要作用是实现或测试 `dir2/foo2.h` 的功能, `foo.cc` 中包含头文件的次序如下:\n\n1. cpp直接的头文件(dir2/foo2.h)\n2. C库\n3. C++库\n4. 其他库的头文件\n5. 项目内的头文件\n\n这种优先的顺序排序保证当 `dir2/foo2.h` 遗漏某些必要的库时， `dir/foo.cc` 或 `dir/foo_test.cc` 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。\n\n按字母顺序分别对每种类型的头文件进行二次排序是不错的主意\n\n您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，哪怕您所包含的 `foo.h` 已经包含了 `bar.h`, 也照样得包含 `bar.h`, 除非 `foo.h` 有明确说明它会自动向您提供 `bar.h` 中的 symbol. \n\n### 2，作用域\n\n#### 2.1 命名空间\n\n禁止使用using\n\n```C++\n// .h 文件\nnamespace mynamespace {\n\n// 所有声明都置于命名空间中\n// 注意不要使用缩进\nclass MyClass {\n    public:\n    ...\n    void Foo();\n};\n\n} // namespace mynamespace\n```\n\n```C++\n// .cc 文件\nnamespace mynamespace {\n\n// 函数定义都置于命名空间中\nvoid MyClass::Foo() {\n    ...\n}\n\n} // namespace mynamespace\n```\n\n#### 2.2 匿名命名空间\n\n```C++\nnamespace {\n...\n}  // 匿名命名空间，编译器自动生成唯一名字\n```\n\n\n\n推荐、鼓励在 `.cc` 中对于不需要在其他地方引用的标识符使用**内部链接性声明** （匿名命名空间和static），但是不要在 `.h` 中使用。\n\n所有置于匿名命名空间的声明都具有内部链接性，名称的作用域被限制在当前文件中，无法通过在另外的文件中使用extern声明来进行链接\n\n函数和变量可以经由声明为 `static` 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。\n\n#### 2.3 静态成员函数与命名空间非成员函数\n\n**尽量不要使用全局函数，非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内，不要使用静态成员方法，类的静态方法应当和类的实例或静态数据紧密相关.**\n\n```C++\nnamespace myproject {\nnamespace foo_bar {\nvoid Function1();\nvoid Function2();  //非成员函数应置于命名空间中\n}  // namespace foo_bar\n}  // namespace myproject\n```\n\n```C++\nnamespace myproject {\nclass FooBar {\n public:\n  static void Function1();\n  static void Function2();\n};\n}  // namespace myproject\n```\n\n#### 2.4 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化,离第一次使用越近越好\n\n```C++\n//Not Like This\nint i;\ni = f(); // 坏——初始化和声明分离\n\n//Better Like This\nint j = g(); // 好——初始化时声明\n```\n\nif, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了\n\n```C++\nwhile (const char* p = strchr(str, '/')) str = p + 1;\n```\n\n有一个例外, 如果**变量是一个对象**, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低，这时应该在循环作用域外面声明这类变量:\n\n```C++\n// 低效的实现\nfor (int i = 0; i < 1000000; ++i) {\n    Foo f;                  // 构造函数和析构函数分别调用 1000000 次!\n    f.DoSomething(i);\n}\n\nFoo f;                      // 构造函数和析构函数只调用 1 次\nfor (int i = 0; i < 1000000; ++i) {\n    f.DoSomething(i);\n}\n```\n\n#### 2.5 静态和全局变量\n\n尽量不用全局函数和全局变量,\n\n多线程中的全局变量 (含静态成员变量) 不要使用 `class` 类型 (含 STL 容器), 因为构造和析构顺序的不确定导致不明确行为导致的 bug.\n\n静态生存周期的对象，即包括了**全局变量，静态变量，静态类成员变量和函数静态变量**，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。即**完全禁用类类型的全局变量**，比如vector(使用 C 数组替代) 和string(使用 `const char []`)。我们也**不允许用函数返回值来初始化 POD 变量**，除非该函数不涉及任何全局变量。\n\n### 3，类\n\n#### 3.1 不要在构造函数中调用虚函数\n\n如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.\n\n#### 3.2 对于单参数构造函数, 请使用explicit关键字来禁止隐式转换\n\n#### 3.3 移动构造函数，移动赋值函数和拷贝构造函数，拷贝赋值函数\n\n```C++\n//拷贝构造函数\nclass ClassName{\n    int *a;\npublic:\n    ClassName(){}     //构造函数\n    ClassName(int x){}  //有参数的构造函数\n    ~ClassName(){delete *a}  //析构函数\n    \n    ClassName(const ClassName &Obj){} //拷贝构造函数\n    ClaaName& operator=(const ClassName &Obj){  //拷贝赋值函数\n        return *this;\n    }\n    \n    ClassName(ClassName &&Obj){}   //移动构造函数\n    ClassName& operator=(ClassName &Obj){  //移动赋值函数\n        return *this;\n    }\n};\n```\n\n##### 3.3.1 **拷贝构造函数:**\n\n```C++\nMyClass foo;\nMyClass bar(foo);       // 对象初始化: 调用拷贝构造函数\nMyClass baz = foo;      // 对象初始化: 调用拷贝构造函数\nfoo = bar;              // 对象已经被初始化，调用拷贝赋值\n```\n\n什么时候用到拷贝构造函数？  \n\n1. 一个对象以值传递的方式传入函数体；\n2. 一个对象以值传递的方式从函数返回； \n3. 一个对象需要通过另外一个对象进行初始化\n\n##### 3.3.2 **深拷贝**  \n\n如果一个类拥有资源，当这个类的对象发生复制过程的时候，**资源重新分配**，例如需要新开辟内存，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。\n\n如对象A=B。这时，如果B中有一个成员变量指针已经申请了内存，浅拷贝(默认拷贝构造函数)则是A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。\n\n##### 3.3.3 **移动构造函数**\n\n移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。  这里未命名的对象就是那些临时变量，甚至都不会有名称。\n\n典型的未命名对象就是**函数的返回值或者类型转换的对象**。  \n\n使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值： \n\n```c++\nMyClass fn();            // 函数返回一个 MyClass 对象\nMyClass foo;             // 默认构造函数\nMyClass bar = foo;       // 拷贝构造函数\nMyClass baz = fn();      // 移动构造函数\nfoo = bar;               // 拷贝赋值\nbaz = MyClass();         // 移动赋值 \n```\n\n##### 3.3.4 **区别:**\n\n拷贝和移动是不同的操作：从A拷贝到B意味着，B分配了新内存，A的整个内容被拷贝到为B分配的新内存上。  而从A移动到B意味着分配给A的内存转移给了B，没有分配新的内存，它仅仅包含简单地拷贝指针。\n\n##### 3.3.5 总结\n\n如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.\n\n如果你的类不需要拷贝 / 移动操作, 请显式地通过在 `public` 域中使用 `= delete` 或其他手段禁用之.\n\n```C++\n// MyClass is neither copyable nor movable.\nMyClass(const MyClass&) = delete;\nMyClass& operator=(const MyClass&) = delete;\n```\n\n####  3.4 仅当只有数据成员时使用struct，其它一概使用class\n\n#### 3.5 继承\n\n组合 > 实现继承 > 接口继承 > 私有继承\n\n##### 3.5.1 组合\n\n组合类：一个类(Head类)里面的数据成员是另一个类的对象，即内嵌其他类的对象作为自己的成员。\n\nEye,Nose,Mouth,Ear这些类都是Head类的一部分\n\n```C++\nclass Eye{void look()};\nclass Nose{};\nclass Mouth{};\nclass Ear{};\nclass Head{\npublic:\n    void look(){\n        m_eye.look()\n    }\nprivate:\n    Eye m_eye;\n};\n```\n\n如果A类是B类的一部分，则不要让B类去继承A类，而是采用组合的形式。如果A类和B类毫无关系，我们不应该为了让B类多一个功能而去让B继承A。如果在逻辑上B是A的一种，即B类的man也是A类的 Hunman的一种我们就可以让B类去继承A类。\n\n##### 3.5.2 继承\n\n所有继承必须是 `public` 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.\n\n对于可能被子类访问的成员函数, 不要过度使用 `protected` 关键字.\n\n数据成员都必须是 [私有的](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#access-control).\n\n#####　3.5.3 虚函数\n\n能够根据**指针**所指类型调用对应的类对象，实现函数调用时的多态性。\n\n虚函数必须声明是指针才有多态，即基类的指针指向了子类的对象，虚函数调用的是子类对象的函数，不是虚函数则调用的是基类对象的函数。\n\n基类的析构函数应该是虚函数。\n\n派生类对象构造的时候先调用基类的构造函数再调用派生类的构造函数，析构的时候先调用派生类析构函数再调用基类析构函数。派生类的析构函数会只析构自己的那部分，这时候如果基类的析构函数不是虚函数，则不能调用基类的析构函数析构从基类继承来的那部分成员，所以就会出现只删一半的现象，造成内存泄漏。\n\n```C++\n//不管析构函数是否是虚函数(即是否加virtual关键词)，delete时基类和子类都会被释放；\nSubClass* pObj = new SubClass(); //子类指针指向子类对象\ndelete pObj; //析构时，调用的子类的析构，即子类的析构函数，先析构子类再析构基类\n\n\nBaseClass* pObj = new SubClass(); //基类指针指向子类对象，\npObj->dosomething();//如果dosomething()是虚函数,则调用的是子类dosomething()函数;如果dosomething()不是虚函数，则该语句调用的是基类的dosomething()函数\ndelete pObj;\n//若析构函数是虚函数(即加上virtual关键词)，delete时基类和子类都会被释放；\n//若析构函数不是虚函数(即不加virtual关键词)，delete时只释放基类，不释放子类；\n```\n\n\n\n#### 3.6 声明顺序\n\n类定义一般应以 `public:` 开始, 后跟 `protected:`, 最后是 `private:`. 省略空部分.\n\n在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: \n\n+ 类型 (包括 `typedef`, `using`和嵌套的结构体与类),\n+ 常量\n+ 工厂函数\n+ 构造函数\n+ 赋值运算符\n+ 析构函数\n+ 其他函数\n+ 数据成员\n\n不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中\n\n### 4，函数\n\n#### 4.1 参数顺序\n\n函数的参数顺序为: 输入参数在先, 后跟输出参数.\n\n #### 4.2 函数长度\n\n如果函数超过 **40 行**, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.\n\n#### 4.3 引用参数\n\n所有按引用传递的参数必须加上 `const`。\n\n输入参数是值参或 `const` 引用，输入参数可以是 `const` 指针，但决不能是非 `const` 的引用参数\n\n输出参数为指针. \n\n```C++\nvoid Foo(const string &in, string *out);\n```\n\n#### 4.4 函数重载\n\n如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 `AppendString()` 和 `AppendInt()` 等, 而不是一口气重载多个 `Append()`. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 `std::vector` 以便使用者可以用 [列表初始化](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#braced-initializer-list) 指定参数. \n\n### 5，其他\n\n#### 5.1 使用 C++ 的类型转换, 如 `static_cast<>()`. 不要使用int y = (int)x等转换方式\n\n#### 5.2 禁止使用 RTTI.\n\n#### 5.3 不使用 C++ 异常.\n\n#### 5.4 只在记录日志时使用流.\n\n不要使用流, 除非是日志接口需要. 使用 `printf` 之类的代替.\n\n#### 5.5 对于迭代器和其他模板对象使用前缀形式 (`++i`) 的自增, 自减运算符.\n\n对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减)，不考虑返回值的话, 前置自增 (`++i`) 通常要比后置自增 (`i++`) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 `i` 进行一次拷贝. 如果 `i` 是迭代器或其他非数值类型, 拷贝的代价是比较大的.\n\n#### 5.6 const\n\nconst变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误.\n\n注意初始化 const 对象时，必须在初始化的同时值初始化。\n\n **我们强烈建议在任何可能的情况下使用 const**\n\n+ 如果函数不会修改传你入的引用或指针类型参数, 该参数应声明为 `const`.\n+ 尽可能将函数声明为 `const`. 访问函数应该总是 `const`. 其他不会修改任何数据成员, 未调用非 `const` 函数, 不会返回数据成员非 `const` 指针或引用的函数也应该声明成 `const`.\n+ 如果数据成员在对象构造之后不再发生变化, 可将其定义为 `const`.\n\n#### 5.7 constexpr \n\n变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 constexpr, 以用来定义 constexpr 变量\n\n#### 5.8 预处理宏\n\n用宏展开性能关键的代码, 现在可以用**内联函数**替代. \n\n用宏表示常量可被**const变量**代替. \n\n用宏 “缩写” 长变量名可被**引用**代替.\n\n使用宏时，应遵守：\n\n+ 不要在 `.h` 文件中定义宏.\n+ 在马上要使用时才进行 `#define`, 使用后要立即 `#undef`.\n+ 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；\n+ 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.\n+ 不要用 `##` 处理函数，类和变量的名字。\n\n#### 5.9 零值\n\n整数用 `0`, 实数用 `0.0`, 指针用 `nullptr` 或 `NULL`, 字符 (串) 用 `'\\0'`.\n\n\n\n#### 5.10 尽可能用 `sizeof(varname)` 代替 `sizeof(type)`.\n\n### 6，命名规范\n\n#### 6.1 文件命名\n\n文件名要全部小写, 可以包含下划线 (`_`) \n\n#### 6.2 类型命名\n\n类型名称的每个单词首字母均大写, 不包含下划线: `MyExcitingClass`, `MyExcitingEnum`\n\n#### 6.3 变量命名\n\n变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接，\n\n**类的成员变量以下划线结尾**，但结构体的就不用。\n\n如: `a_local_variable`, `a_struct_data_member`, `a_class_data_member_`.\n\n#### 6.4 常量命名\n\n声明为 `constexpr` 或 `const` 的变量, 或在程序运行期间其值始终保持不变的, 命名时以**k**开头, 大小写混合. 例如:\n\n```C++\nconst int kDaysInAWeek = 7;\n```\n\n#### 6.5 函数命名\n\n一般来说, 函数名的每个单词首字母大写，没有下划线。\n\n对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 `StartRpc()` 而非 `StartRPC()`).\n\n#### 6.6 命名空间\n\n命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.\n\n顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.\n\n注意 [不使用缩写作为名称](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#general-naming-rules) 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.\n\n### 7，格式\n\n#### 7.1 每一行代码字符数不超过 80.\n\n#### 7.2 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.\n\n#### 7.3 函数声明与调用\n\n返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 [函数调用](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#function-calls) 一致.\n\n```C++\nReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {\n  DoSomething();\n  ...\n}\n```\n\n如果同一行文本太多, 放不下所有参数:\n\n```C++\nReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,\n                                             Type par_name3) {\n  DoSomething();\n  ...\n}\n\nReturnType LongClassName::ReallyReallyReallyLongFunctionName(\n    Type par_name1,  // 4 space indent\n    Type par_name2,\n    Type par_name3) {\n  DoSomething();  // 2 space indent\n  ...\n}\n```\n\n注意：\n\n+ 使用好的参数名.\n+ 只有在参数未被使用或者其用途非常明显时, 才能省略参数名.\n+ 如果返回类型和函数名在一行放不下, 分行.\n+ 如果返回类型与函数声明或定义分行了, 不要缩进.\n+ 左圆括号总是和函数名在同一行.\n+ 函数名和左圆括号间永远没有空格.\n+ 圆括号与参数间没有空格.\n+ 左大括号总在最后一个参数同一行的末尾处, 不另起新行.\n+ 右大括号总是单独位于函数最后一行, 或者与左大括号同一行.\n+ 右圆括号和左大括号间总是有一个空格.\n+ 所有形参应尽可能对齐.\n+ 缺省缩进为 2 个空格.\n+ 换行后的参数保持 4 个空格的缩进.\n\n#### 7.4 条件语句\n\n注意所有情况下 `if` 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:\n\n```C++\nif ( condition ) {  // 圆括号与空格紧邻 - 不常见\n  ...  // 2 空格缩进.\n} else if ( condition2 ) {  // else 与 if 的右括号同一行.\n  ...\n} else {\n  ...  \n}\n\n// 只要其中一个分支用了大括号, 两个分支都要用上大括号.\nif (condition) {\n  foo;\n} else {\n  bar;\n}\n```\n\n#### 7.5 循环语句与ｓｗｉｔｃｈ\n\n```C++\nswitch (var) {\n  case 0: {  // 2 空格缩进\n    ...      // 4 空格缩进\n    break;\n  }\n  case 1: {\n    ...\n    break;\n  }\n  default: {\n    assert(false);\n  }\n}\n\n\nwhile (condition) {\n  // 反复循环直到条件失效.\n}\nfor (int i = 0; i < kSomeNumber; ++i) {}  // 可 - 空循环体.\nwhile (condition) continue;  // 可 - contunue 表明没有逻辑.\n```\n\n#### 7.6 指针与引用\n\n句点或箭头前后不要有空格. 指针/地址操作符 (`*, &`) 之后不能有空格.\n\n- 在访问成员时, 句点或箭头前后没有空格.\n- 指针操作符 `*` 或 `&` 后没有空格.\n\n```C++\nx = *p;\np = &x;\nx = r.y;\nx = r->y;\n// 好, 空格前置.\nchar *c;\nconst string &str;\n\n// 好, 空格后置.\nchar* c;\nconst string& str;\n\nint x, *y;  // 不允许 - 在多重声明中不能使用 & 或 *\nchar * c;  // 差 - * 两边都有空格\nconst string & str;  // 差 - & 两边都有空格.\n```\n\n#### 7.7 变量与数组初始化\n\n用 `=`, `()` 和 `{}` 均可.\n\n```C++\nint x = 3;\nint x(3);\nint x{3};\nstring name(\"Some Name\");\nstring name = \"Some Name\";\nstring name{\"Some Name\"};\n\nvector<int> v(100, 1);  // 内容为 100 个 1 的向量.\nvector<int> v{100, 1};  // 内容为 100 和 1 的向量.\n```\n\n#### 7.8 类格式\n\n访问控制块的声明依次序是 `public:`, `protected:`, `private:`, 每个都缩进 1 个空格.\n\n```C++\nclass MyClass : public OtherClass {\n public:      // 注意有一个空格的缩进\n  MyClass();  // 标准的两空格缩进\n  explicit MyClass(int var);\n  ~MyClass() {}\n\n  void SomeFunction();\n  void SomeFunctionThatDoesNothing() {\n  }\n\n  void set_some_var(int var) { some_var_ = var; }\n  int some_var() const { return some_var_; }\n\n private:\n  bool SomeInternalFunction();\n\n  int some_var_;\n  int some_other_var_;\n};\n```\n\n注意：\n\n+ 所有基类名应在 80 列限制下尽量与子类名放在同一行.\n+ 关键词 `public:`, `protected:`, `private:` 要缩进 1 个空格.\n+ 除第一个关键词 (一般是 `public`) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.\n+ 这些关键词后不要保留空行.\n+ `public` 放在最前面, 然后是 `protected`, 最后是 `private`.\n+ 关于声明顺序的规则请参考 [声明顺序](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#declaration-order) 一节.\n\n#### 7.9 初始化列表\n\n构造函数初始化列表放在同一行或按四格缩进并排多行.\n\n```C++\n// 如果所有变量能放在同一行:\nMyClass::MyClass(int var) : some_var_(var) {\n  DoSomething();\n}\n\n// 如果不能放在同一行,\n// 必须置于冒号后, 并缩进 4 个空格\nMyClass::MyClass(int var)\n    : some_var_(var), some_other_var_(var + 1) {\n  DoSomething();\n}\n\n// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行\n// 并逐行对齐\nMyClass::MyClass(int var)\n    : some_var_(var),             // 4 space indent\n      some_other_var_(var + 1) {  // lined up\n  DoSomething();\n}\n\n// 右大括号 } 可以和左大括号 { 放在同一行\n// 如果这样做合适的话\nMyClass::MyClass(int var)\n    : some_var_(var) {}\n```\n\n#### 7.10 命名空间\n\n```C++\nnamespace {\n\nvoid foo() {  // 正确. 命名空间内没有额外的缩进.\n  ...\n}\n\n}  // namespace\n\n//不要在命名空间内缩进\nnamespace {\n\n  // 错, 缩进多余了.\n  void foo() {\n    ...\n  }\n\n}  // namespace\n```\n\n通用\n\n```C++\n\nvoid f(bool b) {  // 左大括号前总是有空格.\n  ...\nint i = 0;  // 分号前不加空格.\n// 列表初始化中大括号内的空格是可选的.\n// 如果加了空格, 那么两边都要加上.\nint x[] = { 0 };\nint x[] = {0};\n\n// 继承与初始化列表中的冒号前后恒有空格.\nclass Foo : public Bar {\n public:\n  // 对于单行函数的实现, 在大括号内加上空格\n  // 然后是函数实现\n  Foo(int b) : Bar(), baz_(b) {}  // 大括号里面是空的话, 不加空格.\n  void Reset() { baz_ = 0; }  // 用括号把大括号与实现分开.\n  ...\n```\n\n```C++\nif (b) {          // if 条件语句和循环语句关键字后均有空格.\n} else {          // else 前后有空格.\n}\nwhile (test) {}   // 圆括号内部不紧邻空格.\nswitch (i) {\nfor (int i = 0; i < 5; ++i) {\nswitch ( i ) {    // 循环和条件语句的圆括号里可以与空格紧邻.\nif ( test ) {     // 圆括号, 但这很少见. 总之要一致.\nfor ( int i = 0; i < 5; ++i ) {\nfor ( ; i < 5 ; ++i) {  // 循环里内 ; 后恒有空格, ;  前可以加个空格.\nswitch (i) {\n  case 1:         // switch case 的冒号前无空格.\n    ...\n  case 2: break;  // 如果冒号有代码, 加个空格.\n```\n\n```c++\n// 赋值运算符前后总是有空格.\nx = 0;\n\n// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.\n// 圆括号内部没有紧邻空格.\nv = w * x + y / z;\nv = w*x + y/z;\nv = w * (x + z);\n\n// 在参数和一元操作符之间不加空格.\nx = -5;\n++x;\nif (x && !y)\n  ...\n```\n\n```C++\n// 尖括号(< and >) 不与空格紧邻, < 前没有空格, > 和 ( 之间也没有.\nvector<string> x;\ny = static_cast<char*>(x);\n\n// 在类型与指针操作符之间留空格也可以, 但要保持一致.\nvector<char *> x;\n```\n\n","tags":["Base"],"categories":["基础学习"]},{"title":"catkin_make ERROR","url":"/[object Object]/catkinerror.html","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n编写完节点源代码后，catkin-make编译包时出现的错误分析。\n<!-- more -->\n<The rest of contents | 余下全文>\n\n\n## CMakelist.txt参数\n\n### project()\n\n包的名字，根据catkin_create_pkg后面的名字命名。注意需要与后面的参数对准。\n\n### find_package()\n\n编译包需要的依赖项。可以自己添加。格式为：\n\n```\nfind_package(catkin REQUIRED COMPONENTS //必须的\n  x  //根据自己编写的源代码需要的依赖项\n  y\n  z\n)\n```\n### include_directories()\n\n如果包有头文件，需要注意该选项。格式为：\n\n```\ninclude_directories(\n  include ${catkin_INCLUDE_DIRS}\n)\n```\n\n### add_executable()\n\n指定编译的文件，以及要生成的可执行文件，即节点。需要注意的是，自动生成的CMakelist文件中，会自动把节点和源文件等命名为xxx_node的格式，需要修改。\n\n```\nadd_executable(${PROJECT_NAME}_node src/mynode_node.cpp) //自动生成的\nadd_executable(${PROJECT_NAME} src/main.cpp src/file1.cpp src/file2.cpp) //正确编译的\n```\n将调用src/main.cpp，src/file1.cpp和src/file2.cpp生成名为myNode的目标可执行文件\n\n### target_link_libraries()\n\n指定生成的可执行文件需要链接的库文件。格式为：\n\n```\ntarget_link_libraries(${PROJECT_NAME}_node\n                      ${catkin_LIBRARIES}\n)\n\n```\n\n## 错误1:Undefined reference to ''ros::init()''\n\n\n出现该编译错误的原因很可能是\n+ 头文件问题\n+ CMakelist.txt问题\n\n### 头文件问题\n检查包含的头文件，有可能写错。\n\n### CMakelist.txt问题\n主要检查以下几个方面：project名字，依赖包是否完整，头文件夹是否包含，\n","tags":["ROS"],"categories":["ROS学习"]}]